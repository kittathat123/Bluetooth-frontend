{"ast":null,"code":"/* shader-particle-engine 1.0.5\n *\n * (c) 2015 Luke Moody (http://www.github.com/squarefeet)\n *     Originally based on Lee Stemkoski's original work (https://github.com/stemkoski/stemkoski.github.com/blob/master/Three.js/js/ParticleEngine.js).\n *\n * shader-particle-engine may be freely distributed under the MIT license (See LICENSE at root of this repository.)\n */\n\n/**\n * @typedef {Number} distribution\n * @property {Number} SPE.distributions.BOX Values will be distributed within a box.\n * @property {Number} SPE.distributions.SPHERE Values will be distributed within a sphere.\n * @property {Number} SPE.distributions.DISC Values will be distributed within a 2D disc.\n */\n\n/**\n * Namespace for Shader Particle Engine.\n *\n * All SPE-related code sits under this namespace.\n *\n * @type {Object}\n * @namespace\n */\nvar SPE = {\n  /**\n   * A map of supported distribution types used\n   * by SPE.Emitter instances.\n   *\n   * These distribution types can be applied to\n   * an emitter globally, which will affect the\n   * `position`, `velocity`, and `acceleration`\n   * value calculations for an emitter, or they\n   * can be applied on a per-property basis.\n   *\n   * @enum {Number}\n   */\n  distributions: {\n    /**\n     * Values will be distributed within a box.\n     * @type {Number}\n     */\n    BOX: 1,\n\n    /**\n     * Values will be distributed on a sphere.\n     * @type {Number}\n     */\n    SPHERE: 2,\n\n    /**\n     * Values will be distributed on a 2d-disc shape.\n     * @type {Number}\n     */\n    DISC: 3\n  },\n\n  /**\n   * Set this value to however many 'steps' you\n   * want value-over-lifetime properties to have.\n   *\n   * It's adjustable to fix an interpolation problem:\n   *\n   * Assuming you specify an opacity value as [0, 1, 0]\n   *      and the `valueOverLifetimeLength` is 4, then the\n   *      opacity value array will be reinterpolated to\n   *      be [0, 0.66, 0.66, 0].\n   *   This isn't ideal, as particles would never reach\n   *   full opacity.\n   *\n   * NOTE:\n   *     This property affects the length of ALL\n   *       value-over-lifetime properties for ALL\n   *       emitters and ALL groups.\n   *\n   *     Only values >= 3 && <= 4 are allowed.\n   *\n   * @type {Number}\n   */\n  valueOverLifetimeLength: 4\n}; // Module loader support:\n\nif (typeof define === 'function' && define.amd) {\n  define('spe', SPE);\n} else if (typeof exports !== 'undefined' && typeof module !== 'undefined') {\n  module.exports = SPE;\n}\n/**\n * A helper class for TypedArrays.\n *\n * Allows for easy resizing, assignment of various component-based\n * types (Vector2s, Vector3s, Vector4s, Mat3s, Mat4s),\n * as well as Colors (where components are `r`, `g`, `b`),\n * Numbers, and setting from other TypedArrays.\n *\n * @author Luke Moody\n * @constructor\n * @param {Function} TypedArrayConstructor The constructor to use (Float32Array, Uint8Array, etc.)\n * @param {Number} size                 The size of the array to create\n * @param {Number} componentSize        The number of components per-value (ie. 3 for a vec3, 9 for a Mat3, etc.)\n * @param {Number} indexOffset          The index in the array from which to start assigning values. Default `0` if none provided\n */\n\n\nSPE.TypedArrayHelper = function (TypedArrayConstructor, size, componentSize, indexOffset) {\n  'use strict';\n\n  this.componentSize = componentSize || 1;\n  this.size = size || 1;\n  this.TypedArrayConstructor = TypedArrayConstructor || Float32Array;\n  this.array = new TypedArrayConstructor(size * this.componentSize);\n  this.indexOffset = indexOffset || 0;\n};\n\nSPE.TypedArrayHelper.constructor = SPE.TypedArrayHelper;\n/**\n * Sets the size of the internal array.\n *\n * Delegates to `this.shrink` or `this.grow` depending on size\n * argument's relation to the current size of the internal array.\n *\n * Note that if the array is to be shrunk, data will be lost.\n *\n * @param {Number} size The new size of the array.\n */\n\nSPE.TypedArrayHelper.prototype.setSize = function (size, noComponentMultiply) {\n  'use strict';\n\n  var currentArraySize = this.array.length;\n\n  if (!noComponentMultiply) {\n    size = size * this.componentSize;\n  }\n\n  if (size < currentArraySize) {\n    return this.shrink(size);\n  } else if (size > currentArraySize) {\n    return this.grow(size);\n  } else {\n    console.info('TypedArray is already of size:', size + '.', 'Will not resize.');\n  }\n};\n/**\n * Shrinks the internal array.\n *\n * @param  {Number} size The new size of the typed array. Must be smaller than `this.array.length`.\n * @return {SPE.TypedArrayHelper}      Instance of this class.\n */\n\n\nSPE.TypedArrayHelper.prototype.shrink = function (size) {\n  'use strict';\n\n  this.array = this.array.subarray(0, size);\n  this.size = size;\n  return this;\n};\n/**\n * Grows the internal array.\n * @param  {Number} size The new size of the typed array. Must be larger than `this.array.length`.\n * @return {SPE.TypedArrayHelper}      Instance of this class.\n */\n\n\nSPE.TypedArrayHelper.prototype.grow = function (size) {\n  'use strict';\n\n  var existingArray = this.array,\n      newArray = new this.TypedArrayConstructor(size);\n  newArray.set(existingArray);\n  this.array = newArray;\n  this.size = size;\n  return this;\n};\n/**\n * Perform a splice operation on this array's buffer.\n * @param  {Number} start The start index of the splice. Will be multiplied by the number of components for this attribute.\n * @param  {Number} end The end index of the splice. Will be multiplied by the number of components for this attribute.\n * @returns {Object} The SPE.TypedArrayHelper instance.\n */\n\n\nSPE.TypedArrayHelper.prototype.splice = function (start, end) {\n  'use strict';\n\n  start *= this.componentSize;\n  end *= this.componentSize;\n  var data = [],\n      array = this.array,\n      size = array.length;\n\n  for (var i = 0; i < size; ++i) {\n    if (i < start || i >= end) {\n      data.push(array[i]);\n    } // array[ i ] = 0;\n\n  }\n\n  this.setFromArray(0, data);\n  return this;\n};\n/**\n * Copies from the given TypedArray into this one, using the index argument\n * as the start position. Alias for `TypedArray.set`. Will automatically resize\n * if the given source array is of a larger size than the internal array.\n *\n * @param {Number} index      The start position from which to copy into this array.\n * @param {TypedArray} array The array from which to copy; the source array.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\n\n\nSPE.TypedArrayHelper.prototype.setFromArray = function (index, array) {\n  'use strict';\n\n  var sourceArraySize = array.length,\n      newSize = index + sourceArraySize;\n\n  if (newSize > this.array.length) {\n    this.grow(newSize);\n  } else if (newSize < this.array.length) {\n    this.shrink(newSize);\n  }\n\n  this.array.set(array, this.indexOffset + index);\n  return this;\n};\n/**\n * Set a Vector2 value at `index`.\n *\n * @param {Number} index The index at which to set the vec2 values from.\n * @param {Vector2} vec2  Any object that has `x` and `y` properties.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\n\n\nSPE.TypedArrayHelper.prototype.setVec2 = function (index, vec2) {\n  'use strict';\n\n  return this.setVec2Components(index, vec2.x, vec2.y);\n};\n/**\n * Set a Vector2 value using raw components.\n *\n * @param {Number} index The index at which to set the vec2 values from.\n * @param {Number} x     The Vec2's `x` component.\n * @param {Number} y     The Vec2's `y` component.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\n\n\nSPE.TypedArrayHelper.prototype.setVec2Components = function (index, x, y) {\n  'use strict';\n\n  var array = this.array,\n      i = this.indexOffset + index * this.componentSize;\n  array[i] = x;\n  array[i + 1] = y;\n  return this;\n};\n/**\n * Set a Vector3 value at `index`.\n *\n * @param {Number} index The index at which to set the vec3 values from.\n * @param {Vector3} vec2  Any object that has `x`, `y`, and `z` properties.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\n\n\nSPE.TypedArrayHelper.prototype.setVec3 = function (index, vec3) {\n  'use strict';\n\n  return this.setVec3Components(index, vec3.x, vec3.y, vec3.z);\n};\n/**\n * Set a Vector3 value using raw components.\n *\n * @param {Number} index The index at which to set the vec3 values from.\n * @param {Number} x     The Vec3's `x` component.\n * @param {Number} y     The Vec3's `y` component.\n * @param {Number} z     The Vec3's `z` component.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\n\n\nSPE.TypedArrayHelper.prototype.setVec3Components = function (index, x, y, z) {\n  'use strict';\n\n  var array = this.array,\n      i = this.indexOffset + index * this.componentSize;\n  array[i] = x;\n  array[i + 1] = y;\n  array[i + 2] = z;\n  return this;\n};\n/**\n * Set a Vector4 value at `index`.\n *\n * @param {Number} index The index at which to set the vec4 values from.\n * @param {Vector4} vec2  Any object that has `x`, `y`, `z`, and `w` properties.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\n\n\nSPE.TypedArrayHelper.prototype.setVec4 = function (index, vec4) {\n  'use strict';\n\n  return this.setVec4Components(index, vec4.x, vec4.y, vec4.z, vec4.w);\n};\n/**\n * Set a Vector4 value using raw components.\n *\n * @param {Number} index The index at which to set the vec4 values from.\n * @param {Number} x     The Vec4's `x` component.\n * @param {Number} y     The Vec4's `y` component.\n * @param {Number} z     The Vec4's `z` component.\n * @param {Number} w     The Vec4's `w` component.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\n\n\nSPE.TypedArrayHelper.prototype.setVec4Components = function (index, x, y, z, w) {\n  'use strict';\n\n  var array = this.array,\n      i = this.indexOffset + index * this.componentSize;\n  array[i] = x;\n  array[i + 1] = y;\n  array[i + 2] = z;\n  array[i + 3] = w;\n  return this;\n};\n/**\n * Set a Matrix3 value at `index`.\n *\n * @param {Number} index The index at which to set the matrix values from.\n * @param {Matrix3} mat3 The 3x3 matrix to set from. Must have a TypedArray property named `elements` to copy from.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\n\n\nSPE.TypedArrayHelper.prototype.setMat3 = function (index, mat3) {\n  'use strict';\n\n  return this.setFromArray(this.indexOffset + index * this.componentSize, mat3.elements);\n};\n/**\n * Set a Matrix4 value at `index`.\n *\n * @param {Number} index The index at which to set the matrix values from.\n * @param {Matrix4} mat3 The 4x4 matrix to set from. Must have a TypedArray property named `elements` to copy from.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\n\n\nSPE.TypedArrayHelper.prototype.setMat4 = function (index, mat4) {\n  'use strict';\n\n  return this.setFromArray(this.indexOffset + index * this.componentSize, mat4.elements);\n};\n/**\n * Set a Color value at `index`.\n *\n * @param {Number} index The index at which to set the vec3 values from.\n * @param {Color} color  Any object that has `r`, `g`, and `b` properties.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\n\n\nSPE.TypedArrayHelper.prototype.setColor = function (index, color) {\n  'use strict';\n\n  return this.setVec3Components(index, color.r, color.g, color.b);\n};\n/**\n * Set a Number value at `index`.\n *\n * @param {Number} index The index at which to set the vec3 values from.\n * @param {Number} numericValue  The number to assign to this index in the array.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\n\n\nSPE.TypedArrayHelper.prototype.setNumber = function (index, numericValue) {\n  'use strict';\n\n  this.array[this.indexOffset + index * this.componentSize] = numericValue;\n  return this;\n};\n/**\n * Returns the value of the array at the given index, taking into account\n * the `indexOffset` property of this class.\n *\n * Note that this function ignores the component size and will just return a\n * single value.\n *\n * @param  {Number} index The index in the array to fetch.\n * @return {Number}       The value at the given index.\n */\n\n\nSPE.TypedArrayHelper.prototype.getValueAtIndex = function (index) {\n  'use strict';\n\n  return this.array[this.indexOffset + index];\n};\n/**\n * Returns the component value of the array at the given index, taking into account\n * the `indexOffset` property of this class.\n *\n * If the componentSize is set to 3, then it will return a new TypedArray\n * of length 3.\n *\n * @param  {Number} index The index in the array to fetch.\n * @return {TypedArray}       The component value at the given index.\n */\n\n\nSPE.TypedArrayHelper.prototype.getComponentValueAtIndex = function (index) {\n  'use strict';\n\n  return this.array.subarray(this.indexOffset + index * this.componentSize);\n};\n/**\n * A helper to handle creating and updating a THREE.BufferAttribute instance.\n *\n * @author  Luke Moody\n * @constructor\n * @param {String} type          The buffer attribute type. See SPE.ShaderAttribute.typeSizeMap for valid values.\n * @param {Boolean=} dynamicBuffer Whether this buffer attribute should be marked as dynamic or not.\n * @param {Function=} arrayType     A reference to a TypedArray constructor. Defaults to Float32Array if none provided.\n */\n\n\nSPE.ShaderAttribute = function (type, dynamicBuffer, arrayType) {\n  'use strict';\n\n  var typeMap = SPE.ShaderAttribute.typeSizeMap;\n  this.type = typeof type === 'string' && typeMap.hasOwnProperty(type) ? type : 'f';\n  this.componentSize = typeMap[this.type];\n  this.arrayType = arrayType || Float32Array;\n  this.typedArray = null;\n  this.bufferAttribute = null;\n  this.dynamicBuffer = !!dynamicBuffer;\n  this.updateMin = 0;\n  this.updateMax = 0;\n};\n\nSPE.ShaderAttribute.constructor = SPE.ShaderAttribute;\n/**\n * A map of uniform types to their component size.\n * @enum {Number}\n */\n\nSPE.ShaderAttribute.typeSizeMap = {\n  /**\n   * Float\n   * @type {Number}\n   */\n  f: 1,\n\n  /**\n   * Vec2\n   * @type {Number}\n   */\n  v2: 2,\n\n  /**\n   * Vec3\n   * @type {Number}\n   */\n  v3: 3,\n\n  /**\n   * Vec4\n   * @type {Number}\n   */\n  v4: 4,\n\n  /**\n   * Color\n   * @type {Number}\n   */\n  c: 3,\n\n  /**\n   * Mat3\n   * @type {Number}\n   */\n  m3: 9,\n\n  /**\n   * Mat4\n   * @type {Number}\n   */\n  m4: 16\n};\n/**\n * Calculate the minimum and maximum update range for this buffer attribute using\n * component size independant min and max values.\n *\n * @param {Number} min The start of the range to mark as needing an update.\n * @param {Number} max The end of the range to mark as needing an update.\n */\n\nSPE.ShaderAttribute.prototype.setUpdateRange = function (min, max) {\n  'use strict';\n\n  this.updateMin = Math.min(min * this.componentSize, this.updateMin * this.componentSize);\n  this.updateMax = Math.max(max * this.componentSize, this.updateMax * this.componentSize);\n};\n/**\n * Calculate the number of indices that this attribute should mark as needing\n * updating. Also marks the attribute as needing an update.\n */\n\n\nSPE.ShaderAttribute.prototype.flagUpdate = function () {\n  'use strict';\n\n  var attr = this.bufferAttribute,\n      range = attr.updateRange;\n  range.offset = this.updateMin;\n  range.count = Math.min(this.updateMax - this.updateMin + this.componentSize, this.typedArray.array.length); // console.log( range.offset, range.count, this.typedArray.array.length );\n  // console.log( 'flagUpdate:', range.offset, range.count );\n\n  attr.needsUpdate = true;\n};\n/**\n * Reset the index update counts for this attribute\n */\n\n\nSPE.ShaderAttribute.prototype.resetUpdateRange = function () {\n  'use strict';\n\n  this.updateMin = 0;\n  this.updateMax = 0;\n};\n\nSPE.ShaderAttribute.prototype.resetDynamic = function () {\n  'use strict';\n\n  this.bufferAttribute.dynamic = this.dynamicBuffer;\n};\n/**\n * Perform a splice operation on this attribute's buffer.\n * @param  {Number} start The start index of the splice. Will be multiplied by the number of components for this attribute.\n * @param  {Number} end The end index of the splice. Will be multiplied by the number of components for this attribute.\n */\n\n\nSPE.ShaderAttribute.prototype.splice = function (start, end) {\n  'use strict';\n\n  this.typedArray.splice(start, end); // Reset the reference to the attribute's typed array\n  // since it has probably changed.\n\n  this.forceUpdateAll();\n};\n\nSPE.ShaderAttribute.prototype.forceUpdateAll = function () {\n  'use strict';\n\n  this.bufferAttribute.array = this.typedArray.array;\n  this.bufferAttribute.updateRange.offset = 0;\n  this.bufferAttribute.updateRange.count = -1;\n  this.bufferAttribute.dynamic = false;\n  this.bufferAttribute.needsUpdate = true;\n};\n/**\n * Make sure this attribute has a typed array associated with it.\n *\n * If it does, then it will ensure the typed array is of the correct size.\n *\n * If not, a new SPE.TypedArrayHelper instance will be created.\n *\n * @param  {Number} size The size of the typed array to create or update to.\n */\n\n\nSPE.ShaderAttribute.prototype._ensureTypedArray = function (size) {\n  'use strict'; // Condition that's most likely to be true at the top: no change.\n\n  if (this.typedArray !== null && this.typedArray.size === size * this.componentSize) {\n    return;\n  } // Resize the array if we need to, telling the TypedArrayHelper to\n  // ignore it's component size when evaluating size.\n  else if (this.typedArray !== null && this.typedArray.size !== size) {\n      this.typedArray.setSize(size);\n    } // This condition should only occur once in an attribute's lifecycle.\n    else if (this.typedArray === null) {\n        this.typedArray = new SPE.TypedArrayHelper(this.arrayType, size, this.componentSize);\n      }\n};\n/**\n * Creates a THREE.BufferAttribute instance if one doesn't exist already.\n *\n * Ensures a typed array is present by calling _ensureTypedArray() first.\n *\n * If a buffer attribute exists already, then it will be marked as needing an update.\n *\n * @param  {Number} size The size of the typed array to create if one doesn't exist, or resize existing array to.\n */\n\n\nSPE.ShaderAttribute.prototype._createBufferAttribute = function (size) {\n  'use strict'; // Make sure the typedArray is present and correct.\n\n  this._ensureTypedArray(size); // Don't create it if it already exists, but do\n  // flag that it needs updating on the next render\n  // cycle.\n\n\n  if (this.bufferAttribute !== null) {\n    this.bufferAttribute.array = this.typedArray.array;\n    this.bufferAttribute.needsUpdate = true;\n    return;\n  }\n\n  this.bufferAttribute = new THREE.BufferAttribute(this.typedArray.array, this.componentSize);\n  this.bufferAttribute.dynamic = this.dynamicBuffer;\n};\n/**\n * Returns the length of the typed array associated with this attribute.\n * @return {Number} The length of the typed array. Will be 0 if no typed array has been created yet.\n */\n\n\nSPE.ShaderAttribute.prototype.getLength = function () {\n  'use strict';\n\n  if (this.typedArray === null) {\n    return 0;\n  }\n\n  return this.typedArray.array.length;\n};\n\nSPE.shaderChunks = {\n  // Register color-packing define statements.\n  defines: ['#define PACKED_COLOR_SIZE 256.0', '#define PACKED_COLOR_DIVISOR 255.0'].join('\\n'),\n  // All uniforms used by vertex / fragment shaders\n  uniforms: ['uniform float deltaTime;', 'uniform float runTime;', 'uniform sampler2D texture;', 'uniform vec4 textureAnimation;', 'uniform float scale;'].join('\\n'),\n  // All attributes used by the vertex shader.\n  //\n  // Note that some attributes are squashed into other ones:\n  //\n  // * Drag is acceleration.w\n  attributes: ['attribute vec4 acceleration;', 'attribute vec3 velocity;', 'attribute vec4 rotation;', 'attribute vec3 rotationCenter;', 'attribute vec4 params;', 'attribute vec4 size;', 'attribute vec4 angle;', 'attribute vec4 color;', 'attribute vec4 opacity;'].join('\\n'),\n  //\n  varyings: ['varying vec4 vColor;', '#ifdef SHOULD_ROTATE_TEXTURE', '    varying float vAngle;', '#endif', '#ifdef SHOULD_CALCULATE_SPRITE', '    varying vec4 vSpriteSheet;', '#endif'].join('\\n'),\n  // Branch-avoiding comparison fns\n  // - http://theorangeduck.com/page/avoiding-shader-conditionals\n  branchAvoidanceFunctions: ['float when_gt(float x, float y) {', '    return max(sign(x - y), 0.0);', '}', 'float when_lt(float x, float y) {', '    return min( max(1.0 - sign(x - y), 0.0), 1.0 );', '}', 'float when_eq( float x, float y ) {', '    return 1.0 - abs( sign( x - y ) );', '}', 'float when_ge(float x, float y) {', '  return 1.0 - when_lt(x, y);', '}', 'float when_le(float x, float y) {', '  return 1.0 - when_gt(x, y);', '}', // Branch-avoiding logical operators\n  // (to be used with above comparison fns)\n  'float and(float a, float b) {', '    return a * b;', '}', 'float or(float a, float b) {', '    return min(a + b, 1.0);', '}'].join('\\n'),\n  // From:\n  // - http://stackoverflow.com/a/12553149\n  // - https://stackoverflow.com/questions/22895237/hexadecimal-to-rgb-values-in-webgl-shader\n  unpackColor: ['vec3 unpackColor( in float hex ) {', '   vec3 c = vec3( 0.0 );', '   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );', '   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );', '   float b = mod( hex, PACKED_COLOR_SIZE );', '   c.r = r / PACKED_COLOR_DIVISOR;', '   c.g = g / PACKED_COLOR_DIVISOR;', '   c.b = b / PACKED_COLOR_DIVISOR;', '   return c;', '}'].join('\\n'),\n  unpackRotationAxis: ['vec3 unpackRotationAxis( in float hex ) {', '   vec3 c = vec3( 0.0 );', '   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );', '   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );', '   float b = mod( hex, PACKED_COLOR_SIZE );', '   c.r = r / PACKED_COLOR_DIVISOR;', '   c.g = g / PACKED_COLOR_DIVISOR;', '   c.b = b / PACKED_COLOR_DIVISOR;', '   c *= vec3( 2.0 );', '   c -= vec3( 1.0 );', '   return c;', '}'].join('\\n'),\n  floatOverLifetime: ['float getFloatOverLifetime( in float positionInTime, in vec4 attr ) {', '    highp float value = 0.0;', '    float deltaAge = positionInTime * float( VALUE_OVER_LIFETIME_LENGTH - 1 );', '    float fIndex = 0.0;', '    float shouldApplyValue = 0.0;', // This might look a little odd, but it's faster in the testing I've done than using branches.\n  // Uses basic maths to avoid branching.\n  //\n  // Take a look at the branch-avoidance functions defined above,\n  // and be sure to check out The Orange Duck site where I got this\n  // from (link above).\n  // Fix for static emitters (age is always zero).\n  '    value += attr[ 0 ] * when_eq( deltaAge, 0.0 );', '', '    for( int i = 0; i < VALUE_OVER_LIFETIME_LENGTH - 1; ++i ) {', '       fIndex = float( i );', '       shouldApplyValue = and( when_gt( deltaAge, fIndex ), when_le( deltaAge, fIndex + 1.0 ) );', '       value += shouldApplyValue * mix( attr[ i ], attr[ i + 1 ], deltaAge - fIndex );', '    }', '', '    return value;', '}'].join('\\n'),\n  colorOverLifetime: ['vec3 getColorOverLifetime( in float positionInTime, in vec3 color1, in vec3 color2, in vec3 color3, in vec3 color4 ) {', '    vec3 value = vec3( 0.0 );', '    value.x = getFloatOverLifetime( positionInTime, vec4( color1.x, color2.x, color3.x, color4.x ) );', '    value.y = getFloatOverLifetime( positionInTime, vec4( color1.y, color2.y, color3.y, color4.y ) );', '    value.z = getFloatOverLifetime( positionInTime, vec4( color1.z, color2.z, color3.z, color4.z ) );', '    return value;', '}'].join('\\n'),\n  paramFetchingFunctions: ['float getAlive() {', '   return params.x;', '}', 'float getAge() {', '   return params.y;', '}', 'float getMaxAge() {', '   return params.z;', '}', 'float getWiggle() {', '   return params.w;', '}'].join('\\n'),\n  forceFetchingFunctions: ['vec4 getPosition( in float age ) {', '   return modelViewMatrix * vec4( position, 1.0 );', '}', 'vec3 getVelocity( in float age ) {', '   return velocity * age;', '}', 'vec3 getAcceleration( in float age ) {', '   return acceleration.xyz * age;', '}'].join('\\n'),\n  rotationFunctions: [// Huge thanks to:\n  // - http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n  '#ifdef SHOULD_ROTATE_PARTICLES', '   mat4 getRotationMatrix( in vec3 axis, in float angle) {', '       axis = normalize(axis);', '       float s = sin(angle);', '       float c = cos(angle);', '       float oc = 1.0 - c;', '', '       return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,', '                   oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,', '                   oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,', '                   0.0,                                0.0,                                0.0,                                1.0);', '   }', '', '   vec3 getRotation( in vec3 pos, in float positionInTime ) {', '      if( rotation.y == 0.0 ) {', '           return pos;', '      }', '', '      vec3 axis = unpackRotationAxis( rotation.x );', '      vec3 center = rotationCenter;', '      vec3 translated;', '      mat4 rotationMatrix;', '      float angle = 0.0;', '      angle += when_eq( rotation.z, 0.0 ) * rotation.y;', '      angle += when_gt( rotation.z, 0.0 ) * mix( 0.0, rotation.y, positionInTime );', '      translated = rotationCenter - pos;', '      rotationMatrix = getRotationMatrix( axis, angle );', '      return center - vec3( rotationMatrix * vec4( translated, 0.0 ) );', '   }', '#endif'].join('\\n'),\n  // Fragment chunks\n  rotateTexture: ['    vec2 vUv = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );', '', '    #ifdef SHOULD_ROTATE_TEXTURE', '       float x = gl_PointCoord.x - 0.5;', '       float y = 1.0 - gl_PointCoord.y - 0.5;', '       float c = cos( -vAngle );', '       float s = sin( -vAngle );', '       vUv = vec2( c * x + s * y + 0.5, c * y - s * x + 0.5 );', '    #endif', '', // Spritesheets overwrite angle calculations.\n  '    #ifdef SHOULD_CALCULATE_SPRITE', '        float framesX = vSpriteSheet.x;', '        float framesY = vSpriteSheet.y;', '        float columnNorm = vSpriteSheet.z;', '        float rowNorm = vSpriteSheet.w;', '        vUv.x = gl_PointCoord.x * framesX + columnNorm;', '        vUv.y = 1.0 - (gl_PointCoord.y * framesY + rowNorm);', '    #endif', '', '    vec4 rotatedTexture = texture2D( texture, vUv );'].join('\\n')\n};\nSPE.shaders = {\n  vertex: [SPE.shaderChunks.defines, SPE.shaderChunks.uniforms, SPE.shaderChunks.attributes, SPE.shaderChunks.varyings, THREE.ShaderChunk.common, THREE.ShaderChunk.logdepthbuf_pars_vertex, THREE.ShaderChunk.fog_pars_vertex, SPE.shaderChunks.branchAvoidanceFunctions, SPE.shaderChunks.unpackColor, SPE.shaderChunks.unpackRotationAxis, SPE.shaderChunks.floatOverLifetime, SPE.shaderChunks.colorOverLifetime, SPE.shaderChunks.paramFetchingFunctions, SPE.shaderChunks.forceFetchingFunctions, SPE.shaderChunks.rotationFunctions, 'vec4 mvPosition;', 'void main() {', //\n  // Setup...\n  //\n  '    highp float age = getAge();', '    highp float alive = getAlive();', '    highp float maxAge = getMaxAge();', '    highp float positionInTime = (age / maxAge);', '    highp float isAlive = when_gt( alive, 0.0 );', '    #ifdef SHOULD_WIGGLE_PARTICLES', '        float wiggleAmount = positionInTime * getWiggle();', '        float wiggleSin = isAlive * sin( wiggleAmount );', '        float wiggleCos = isAlive * cos( wiggleAmount );', '    #endif', //\n  // Forces\n  //\n  // Get forces & position\n  '    vec3 vel = getVelocity( age );', '    vec3 accel = getAcceleration( age );', '    vec3 force = vec3( 0.0 );', '    vec3 pos = vec3( position );', // Calculate the required drag to apply to the forces.\n  '    float drag = 1.0 - (positionInTime * 0.5) * acceleration.w;', // Integrate forces...\n  '    force += vel;', '    force *= drag;', '    force += accel * age;', '    pos += force;', // Wiggly wiggly wiggle!\n  '    #ifdef SHOULD_WIGGLE_PARTICLES', '        pos.x += wiggleSin;', '        pos.y += wiggleCos;', '        pos.z += wiggleSin;', '    #endif', // Rotate the emitter around it's central point\n  '    #ifdef SHOULD_ROTATE_PARTICLES', '        pos = getRotation( pos, positionInTime );', '    #endif', // Convert pos to a world-space value\n  '    vec4 mvPos = mvPosition = modelViewMatrix * vec4( pos, 1.0 );', // Determine point size.\n  '    highp float pointSize = getFloatOverLifetime( positionInTime, size ) * isAlive;', // Determine perspective\n  '    #ifdef HAS_PERSPECTIVE', '        float perspective = scale / length( mvPos.xyz );', '    #else', '        float perspective = 1.0;', '    #endif', // Apply perpective to pointSize value\n  '    float pointSizePerspective = pointSize * perspective;', //\n  // Appearance\n  //\n  // Determine color and opacity for this particle\n  '    #ifdef COLORIZE', '       vec3 c = isAlive * getColorOverLifetime(', '           positionInTime,', '           unpackColor( color.x ),', '           unpackColor( color.y ),', '           unpackColor( color.z ),', '           unpackColor( color.w )', '       );', '    #else', '       vec3 c = vec3(1.0);', '    #endif', '    float o = isAlive * getFloatOverLifetime( positionInTime, opacity );', // Assign color to vColor varying.\n  '    vColor = vec4( c, o );', // Determine angle\n  '    #ifdef SHOULD_ROTATE_TEXTURE', '        vAngle = isAlive * getFloatOverLifetime( positionInTime, angle );', '    #endif', // If this particle is using a sprite-sheet as a texture, we'll have to figure out\n  // what frame of the texture the particle is using at it's current position in time.\n  '    #ifdef SHOULD_CALCULATE_SPRITE', '        float framesX = textureAnimation.x;', '        float framesY = textureAnimation.y;', '        float loopCount = textureAnimation.w;', '        float totalFrames = textureAnimation.z;', '        float frameNumber = mod( (positionInTime * loopCount) * totalFrames, totalFrames );', '        float column = floor(mod( frameNumber, framesX ));', '        float row = floor( (frameNumber - column) / framesX );', '        float columnNorm = column / framesX;', '        float rowNorm = row / framesY;', '        vSpriteSheet.x = 1.0 / framesX;', '        vSpriteSheet.y = 1.0 / framesY;', '        vSpriteSheet.z = columnNorm;', '        vSpriteSheet.w = rowNorm;', '    #endif', //\n  // Write values\n  //\n  // Set PointSize according to size at current point in time.\n  '    gl_PointSize = pointSizePerspective;', '    gl_Position = projectionMatrix * mvPos;', THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.fog_vertex, '}'].join('\\n'),\n  fragment: [SPE.shaderChunks.uniforms, THREE.ShaderChunk.common, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, SPE.shaderChunks.varyings, SPE.shaderChunks.branchAvoidanceFunctions, 'void main() {', '    vec3 outgoingLight = vColor.xyz;', '    ', '    #ifdef ALPHATEST', '       if ( vColor.w < float(ALPHATEST) ) discard;', '    #endif', SPE.shaderChunks.rotateTexture, THREE.ShaderChunk.logdepthbuf_fragment, '    outgoingLight = vColor.xyz * rotatedTexture.xyz;', '    gl_FragColor = vec4( outgoingLight.xyz, rotatedTexture.w * vColor.w );', THREE.ShaderChunk.fog_fragment, '}'].join('\\n')\n};\n/**\n * A bunch of utility functions used throughout the library.\n * @namespace\n * @type {Object}\n */\n\nSPE.utils = {\n  /**\n   * A map of types used by `SPE.utils.ensureTypedArg` and\n   * `SPE.utils.ensureArrayTypedArg` to compare types against.\n   *\n   * @enum {String}\n   */\n  types: {\n    /**\n     * Boolean type.\n     * @type {String}\n     */\n    BOOLEAN: 'boolean',\n\n    /**\n     * String type.\n     * @type {String}\n     */\n    STRING: 'string',\n\n    /**\n     * Number type.\n     * @type {String}\n     */\n    NUMBER: 'number',\n\n    /**\n     * Object type.\n     * @type {String}\n     */\n    OBJECT: 'object'\n  },\n\n  /**\n   * Given a value, a type, and a default value to fallback to,\n   * ensure the given argument adheres to the type requesting,\n   * returning the default value if type check is false.\n   *\n   * @param  {(boolean|string|number|object)} arg          The value to perform a type-check on.\n   * @param  {String} type         The type the `arg` argument should adhere to.\n   * @param  {(boolean|string|number|object)} defaultValue A default value to fallback on if the type check fails.\n   * @return {(boolean|string|number|object)}              The given value if type check passes, or the default value if it fails.\n   */\n  ensureTypedArg: function (arg, type, defaultValue) {\n    'use strict';\n\n    if (typeof arg === type) {\n      return arg;\n    } else {\n      return defaultValue;\n    }\n  },\n\n  /**\n   * Given an array of values, a type, and a default value,\n   * ensure the given array's contents ALL adhere to the provided type,\n   * returning the default value if type check fails.\n   *\n   * If the given value to check isn't an Array, delegates to SPE.utils.ensureTypedArg.\n   *\n   * @param  {Array|boolean|string|number|object} arg          The array of values to check type of.\n   * @param  {String} type         The type that should be adhered to.\n   * @param  {(boolean|string|number|object)} defaultValue A default fallback value.\n   * @return {(boolean|string|number|object)}              The given value if type check passes, or the default value if it fails.\n   */\n  ensureArrayTypedArg: function (arg, type, defaultValue) {\n    'use strict'; // If the argument being checked is an array, loop through\n    // it and ensure all the values are of the correct type,\n    // falling back to the defaultValue if any aren't.\n\n    if (Array.isArray(arg)) {\n      for (var i = arg.length - 1; i >= 0; --i) {\n        if (typeof arg[i] !== type) {\n          return defaultValue;\n        }\n      }\n\n      return arg;\n    } // If the arg isn't an array then just fallback to\n    // checking the type.\n\n\n    return this.ensureTypedArg(arg, type, defaultValue);\n  },\n\n  /**\n   * Ensures the given value is an instance of a constructor function.\n   *\n   * @param  {Object} arg          The value to check instance of.\n   * @param  {Function} instance     The constructor of the instance to check against.\n   * @param  {Object} defaultValue A default fallback value if instance check fails\n   * @return {Object}              The given value if type check passes, or the default value if it fails.\n   */\n  ensureInstanceOf: function (arg, instance, defaultValue) {\n    'use strict';\n\n    if (instance !== undefined && arg instanceof instance) {\n      return arg;\n    } else {\n      return defaultValue;\n    }\n  },\n\n  /**\n   * Given an array of values, ensure the instances of all items in the array\n   * matches the given instance constructor falling back to a default value if\n   * the check fails.\n   *\n   * If given value isn't an Array, delegates to `SPE.utils.ensureInstanceOf`.\n   *\n   * @param  {Array|Object} arg          The value to perform the instanceof check on.\n   * @param  {Function} instance     The constructor of the instance to check against.\n   * @param  {Object} defaultValue A default fallback value if instance check fails\n   * @return {Object}              The given value if type check passes, or the default value if it fails.\n   */\n  ensureArrayInstanceOf: function (arg, instance, defaultValue) {\n    'use strict'; // If the argument being checked is an array, loop through\n    // it and ensure all the values are of the correct type,\n    // falling back to the defaultValue if any aren't.\n\n    if (Array.isArray(arg)) {\n      for (var i = arg.length - 1; i >= 0; --i) {\n        if (instance !== undefined && arg[i] instanceof instance === false) {\n          return defaultValue;\n        }\n      }\n\n      return arg;\n    } // If the arg isn't an array then just fallback to\n    // checking the type.\n\n\n    return this.ensureInstanceOf(arg, instance, defaultValue);\n  },\n\n  /**\n   * Ensures that any \"value-over-lifetime\" properties of an emitter are\n   * of the correct length (as dictated by `SPE.valueOverLifetimeLength`).\n   *\n   * Delegates to `SPE.utils.interpolateArray` for array resizing.\n   *\n   * If properties aren't arrays, then property values are put into one.\n   *\n   * @param  {Object} property  The property of an SPE.Emitter instance to check compliance of.\n   * @param  {Number} minLength The minimum length of the array to create.\n   * @param  {Number} maxLength The maximum length of the array to create.\n   */\n  ensureValueOverLifetimeCompliance: function (property, minLength, maxLength) {\n    'use strict';\n\n    minLength = minLength || 3;\n    maxLength = maxLength || 3; // First, ensure both properties are arrays.\n\n    if (Array.isArray(property._value) === false) {\n      property._value = [property._value];\n    }\n\n    if (Array.isArray(property._spread) === false) {\n      property._spread = [property._spread];\n    }\n\n    var valueLength = this.clamp(property._value.length, minLength, maxLength),\n        spreadLength = this.clamp(property._spread.length, minLength, maxLength),\n        desiredLength = Math.max(valueLength, spreadLength);\n\n    if (property._value.length !== desiredLength) {\n      property._value = this.interpolateArray(property._value, desiredLength);\n    }\n\n    if (property._spread.length !== desiredLength) {\n      property._spread = this.interpolateArray(property._spread, desiredLength);\n    }\n  },\n\n  /**\n   * Performs linear interpolation (lerp) on an array.\n   *\n   * For example, lerping [1, 10], with a `newLength` of 10 will produce [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].\n   *\n   * Delegates to `SPE.utils.lerpTypeAgnostic` to perform the actual\n   * interpolation.\n   *\n   * @param  {Array} srcArray  The array to lerp.\n   * @param  {Number} newLength The length the array should be interpolated to.\n   * @return {Array}           The interpolated array.\n   */\n  interpolateArray: function (srcArray, newLength) {\n    'use strict';\n\n    var sourceLength = srcArray.length,\n        newArray = [typeof srcArray[0].clone === 'function' ? srcArray[0].clone() : srcArray[0]],\n        factor = (sourceLength - 1) / (newLength - 1);\n\n    for (var i = 1; i < newLength - 1; ++i) {\n      var f = i * factor,\n          before = Math.floor(f),\n          after = Math.ceil(f),\n          delta = f - before;\n      newArray[i] = this.lerpTypeAgnostic(srcArray[before], srcArray[after], delta);\n    }\n\n    newArray.push(typeof srcArray[sourceLength - 1].clone === 'function' ? srcArray[sourceLength - 1].clone() : srcArray[sourceLength - 1]);\n    return newArray;\n  },\n\n  /**\n   * Clamp a number to between the given min and max values.\n   * @param  {Number} value The number to clamp.\n   * @param  {Number} min   The minimum value.\n   * @param  {Number} max   The maximum value.\n   * @return {Number}       The clamped number.\n   */\n  clamp: function (value, min, max) {\n    'use strict';\n\n    return Math.max(min, Math.min(value, max));\n  },\n\n  /**\n   * If the given value is less than the epsilon value, then return\n   * a randomised epsilon value if specified, or just the epsilon value if not.\n   * Works for negative numbers as well as positive.\n   *\n   * @param  {Number} value     The value to perform the operation on.\n   * @param  {Boolean} randomise Whether the value should be randomised.\n   * @return {Number}           The result of the operation.\n   */\n  zeroToEpsilon: function (value, randomise) {\n    'use strict';\n\n    var epsilon = 0.00001,\n        result = value;\n    result = randomise ? Math.random() * epsilon * 10 : epsilon;\n\n    if (value < 0 && value > -epsilon) {\n      result = -result;\n    } // if ( value === 0 ) {\n    //     result = randomise ? Math.random() * epsilon * 10 : epsilon;\n    // }\n    // else if ( value > 0 && value < epsilon ) {\n    //     result = randomise ? Math.random() * epsilon * 10 : epsilon;\n    // }\n    // else if ( value < 0 && value > -epsilon ) {\n    //     result = -( randomise ? Math.random() * epsilon * 10 : epsilon );\n    // }\n\n\n    return result;\n  },\n\n  /**\n   * Linearly interpolates two values of various types. The given values\n   * must be of the same type for the interpolation to work.\n   * @param  {(number|Object)} start The start value of the lerp.\n   * @param  {(number|object)} end   The end value of the lerp.\n   * @param  {Number} delta The delta posiiton of the lerp operation. Ideally between 0 and 1 (inclusive).\n   * @return {(number|object|undefined)}       The result of the operation. Result will be undefined if\n   *                                               the start and end arguments aren't a supported type, or\n   *                                               if their types do not match.\n   */\n  lerpTypeAgnostic: function (start, end, delta) {\n    'use strict';\n\n    var types = this.types,\n        out;\n\n    if (typeof start === types.NUMBER && typeof end === types.NUMBER) {\n      return start + (end - start) * delta;\n    } else if (start instanceof THREE.Vector2 && end instanceof THREE.Vector2) {\n      out = start.clone();\n      out.x = this.lerp(start.x, end.x, delta);\n      out.y = this.lerp(start.y, end.y, delta);\n      return out;\n    } else if (start instanceof THREE.Vector3 && end instanceof THREE.Vector3) {\n      out = start.clone();\n      out.x = this.lerp(start.x, end.x, delta);\n      out.y = this.lerp(start.y, end.y, delta);\n      out.z = this.lerp(start.z, end.z, delta);\n      return out;\n    } else if (start instanceof THREE.Vector4 && end instanceof THREE.Vector4) {\n      out = start.clone();\n      out.x = this.lerp(start.x, end.x, delta);\n      out.y = this.lerp(start.y, end.y, delta);\n      out.z = this.lerp(start.z, end.z, delta);\n      out.w = this.lerp(start.w, end.w, delta);\n      return out;\n    } else if (start instanceof THREE.Color && end instanceof THREE.Color) {\n      out = start.clone();\n      out.r = this.lerp(start.r, end.r, delta);\n      out.g = this.lerp(start.g, end.g, delta);\n      out.b = this.lerp(start.b, end.b, delta);\n      return out;\n    } else {\n      console.warn('Invalid argument types, or argument types do not match:', start, end);\n    }\n  },\n\n  /**\n   * Perform a linear interpolation operation on two numbers.\n   * @param  {Number} start The start value.\n   * @param  {Number} end   The end value.\n   * @param  {Number} delta The position to interpolate to.\n   * @return {Number}       The result of the lerp operation.\n   */\n  lerp: function (start, end, delta) {\n    'use strict';\n\n    return start + (end - start) * delta;\n  },\n\n  /**\n   * Rounds a number to a nearest multiple.\n   *\n   * @param  {Number} n        The number to round.\n   * @param  {Number} multiple The multiple to round to.\n   * @return {Number}          The result of the round operation.\n   */\n  roundToNearestMultiple: function (n, multiple) {\n    'use strict';\n\n    var remainder = 0;\n\n    if (multiple === 0) {\n      return n;\n    }\n\n    remainder = Math.abs(n) % multiple;\n\n    if (remainder === 0) {\n      return n;\n    }\n\n    if (n < 0) {\n      return -(Math.abs(n) - remainder);\n    }\n\n    return n + multiple - remainder;\n  },\n\n  /**\n   * Check if all items in an array are equal. Uses strict equality.\n   *\n   * @param  {Array} array The array of values to check equality of.\n   * @return {Boolean}       Whether the array's values are all equal or not.\n   */\n  arrayValuesAreEqual: function (array) {\n    'use strict';\n\n    for (var i = 0; i < array.length - 1; ++i) {\n      if (array[i] !== array[i + 1]) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n  // colorsAreEqual: function() {\n  //     var colors = Array.prototype.slice.call( arguments ),\n  //         numColors = colors.length;\n  //     for ( var i = 0, color1, color2; i < numColors - 1; ++i ) {\n  //         color1 = colors[ i ];\n  //         color2 = colors[ i + 1 ];\n  //         if (\n  //             color1.r !== color2.r ||\n  //             color1.g !== color2.g ||\n  //             color1.b !== color2.b\n  //         ) {\n  //             return false\n  //         }\n  //     }\n  //     return true;\n  // },\n\n  /**\n   * Given a start value and a spread value, create and return a random\n   * number.\n   * @param  {Number} base   The start value.\n   * @param  {Number} spread The size of the random variance to apply.\n   * @return {Number}        A randomised number.\n   */\n  randomFloat: function (base, spread) {\n    'use strict';\n\n    return base + spread * (Math.random() - 0.5);\n  },\n\n  /**\n   * Given an SPE.ShaderAttribute instance, and various other settings,\n   * assign values to the attribute's array in a `vec3` format.\n   *\n   * @param  {Object} attribute   The instance of SPE.ShaderAttribute to save the result to.\n   * @param  {Number} index       The offset in the attribute's TypedArray to save the result from.\n   * @param  {Object} base        THREE.Vector3 instance describing the start value.\n   * @param  {Object} spread      THREE.Vector3 instance describing the random variance to apply to the start value.\n   * @param  {Object} spreadClamp THREE.Vector3 instance describing the multiples to clamp the randomness to.\n   */\n  randomVector3: function (attribute, index, base, spread, spreadClamp) {\n    'use strict';\n\n    var x = base.x + (Math.random() * spread.x - spread.x * 0.5),\n        y = base.y + (Math.random() * spread.y - spread.y * 0.5),\n        z = base.z + (Math.random() * spread.z - spread.z * 0.5); // var x = this.randomFloat( base.x, spread.x ),\n    // y = this.randomFloat( base.y, spread.y ),\n    // z = this.randomFloat( base.z, spread.z );\n\n    if (spreadClamp) {\n      x = -spreadClamp.x * 0.5 + this.roundToNearestMultiple(x, spreadClamp.x);\n      y = -spreadClamp.y * 0.5 + this.roundToNearestMultiple(y, spreadClamp.y);\n      z = -spreadClamp.z * 0.5 + this.roundToNearestMultiple(z, spreadClamp.z);\n    }\n\n    attribute.typedArray.setVec3Components(index, x, y, z);\n  },\n\n  /**\n   * Given an SPE.Shader attribute instance, and various other settings,\n   * assign Color values to the attribute.\n   * @param  {Object} attribute The instance of SPE.ShaderAttribute to save the result to.\n   * @param  {Number} index     The offset in the attribute's TypedArray to save the result from.\n   * @param  {Object} base      THREE.Color instance describing the start color.\n   * @param  {Object} spread    THREE.Vector3 instance describing the random variance to apply to the start color.\n   */\n  randomColor: function (attribute, index, base, spread) {\n    'use strict';\n\n    var r = base.r + Math.random() * spread.x,\n        g = base.g + Math.random() * spread.y,\n        b = base.b + Math.random() * spread.z;\n    r = this.clamp(r, 0, 1);\n    g = this.clamp(g, 0, 1);\n    b = this.clamp(b, 0, 1);\n    attribute.typedArray.setVec3Components(index, r, g, b);\n  },\n  randomColorAsHex: function () {\n    'use strict';\n\n    var workingColor = new THREE.Color();\n    /**\n     * Assigns a random color value, encoded as a hex value in decimal\n     * format, to a SPE.ShaderAttribute instance.\n     * @param  {Object} attribute The instance of SPE.ShaderAttribute to save the result to.\n     * @param  {Number} index     The offset in the attribute's TypedArray to save the result from.\n     * @param  {Object} base      THREE.Color instance describing the start color.\n     * @param  {Object} spread    THREE.Vector3 instance describing the random variance to apply to the start color.\n     */\n\n    return function (attribute, index, base, spread) {\n      var numItems = base.length,\n          colors = [];\n\n      for (var i = 0; i < numItems; ++i) {\n        var spreadVector = spread[i];\n        workingColor.copy(base[i]);\n        workingColor.r += Math.random() * spreadVector.x - spreadVector.x * 0.5;\n        workingColor.g += Math.random() * spreadVector.y - spreadVector.y * 0.5;\n        workingColor.b += Math.random() * spreadVector.z - spreadVector.z * 0.5;\n        workingColor.r = this.clamp(workingColor.r, 0, 1);\n        workingColor.g = this.clamp(workingColor.g, 0, 1);\n        workingColor.b = this.clamp(workingColor.b, 0, 1);\n        colors.push(workingColor.getHex());\n      }\n\n      attribute.typedArray.setVec4Components(index, colors[0], colors[1], colors[2], colors[3]);\n    };\n  }(),\n\n  /**\n   * Assigns a random vector 3 value to an SPE.ShaderAttribute instance, projecting the\n   * given values onto a sphere.\n   *\n   * @param  {Object} attribute The instance of SPE.ShaderAttribute to save the result to.\n   * @param  {Number} index     The offset in the attribute's TypedArray to save the result from.\n   * @param  {Object} base              THREE.Vector3 instance describing the origin of the transform.\n   * @param  {Number} radius            The radius of the sphere to project onto.\n   * @param  {Number} radiusSpread      The amount of randomness to apply to the projection result\n   * @param  {Object} radiusScale       THREE.Vector3 instance describing the scale of each axis of the sphere.\n   * @param  {Number} radiusSpreadClamp What numeric multiple the projected value should be clamped to.\n   */\n  randomVector3OnSphere: function (attribute, index, base, radius, radiusSpread, radiusScale, radiusSpreadClamp, distributionClamp) {\n    'use strict';\n\n    var depth = 2 * Math.random() - 1,\n        t = 6.2832 * Math.random(),\n        r = Math.sqrt(1 - depth * depth),\n        rand = this.randomFloat(radius, radiusSpread),\n        x = 0,\n        y = 0,\n        z = 0;\n\n    if (radiusSpreadClamp) {\n      rand = Math.round(rand / radiusSpreadClamp) * radiusSpreadClamp;\n    } // Set position on sphere\n\n\n    x = r * Math.cos(t) * rand;\n    y = r * Math.sin(t) * rand;\n    z = depth * rand; // Apply radius scale to this position\n\n    x *= radiusScale.x;\n    y *= radiusScale.y;\n    z *= radiusScale.z; // Translate to the base position.\n\n    x += base.x;\n    y += base.y;\n    z += base.z; // Set the values in the typed array.\n\n    attribute.typedArray.setVec3Components(index, x, y, z);\n  },\n  seededRandom: function (seed) {\n    var x = Math.sin(seed) * 10000;\n    return x - (x | 0);\n  },\n\n  /**\n   * Assigns a random vector 3 value to an SPE.ShaderAttribute instance, projecting the\n   * given values onto a 2d-disc.\n   *\n   * @param  {Object} attribute The instance of SPE.ShaderAttribute to save the result to.\n   * @param  {Number} index     The offset in the attribute's TypedArray to save the result from.\n   * @param  {Object} base              THREE.Vector3 instance describing the origin of the transform.\n   * @param  {Number} radius            The radius of the sphere to project onto.\n   * @param  {Number} radiusSpread      The amount of randomness to apply to the projection result\n   * @param  {Object} radiusScale       THREE.Vector3 instance describing the scale of each axis of the disc. The z-component is ignored.\n   * @param  {Number} radiusSpreadClamp What numeric multiple the projected value should be clamped to.\n   */\n  randomVector3OnDisc: function (attribute, index, base, radius, radiusSpread, radiusScale, radiusSpreadClamp) {\n    'use strict';\n\n    var t = 6.2832 * Math.random(),\n        rand = Math.abs(this.randomFloat(radius, radiusSpread)),\n        x = 0,\n        y = 0,\n        z = 0;\n\n    if (radiusSpreadClamp) {\n      rand = Math.round(rand / radiusSpreadClamp) * radiusSpreadClamp;\n    } // Set position on sphere\n\n\n    x = Math.cos(t) * rand;\n    y = Math.sin(t) * rand; // Apply radius scale to this position\n\n    x *= radiusScale.x;\n    y *= radiusScale.y; // Translate to the base position.\n\n    x += base.x;\n    y += base.y;\n    z += base.z; // Set the values in the typed array.\n\n    attribute.typedArray.setVec3Components(index, x, y, z);\n  },\n  randomDirectionVector3OnSphere: function () {\n    'use strict';\n\n    var v = new THREE.Vector3();\n    /**\n     * Given an SPE.ShaderAttribute instance, create a direction vector from the given\n     * position, using `speed` as the magnitude. Values are saved to the attribute.\n     *\n     * @param  {Object} attribute       The instance of SPE.ShaderAttribute to save the result to.\n     * @param  {Number} index           The offset in the attribute's TypedArray to save the result from.\n     * @param  {Number} posX            The particle's x coordinate.\n     * @param  {Number} posY            The particle's y coordinate.\n     * @param  {Number} posZ            The particle's z coordinate.\n     * @param  {Object} emitterPosition THREE.Vector3 instance describing the emitter's base position.\n     * @param  {Number} speed           The magnitude to apply to the vector.\n     * @param  {Number} speedSpread     The amount of randomness to apply to the magnitude.\n     */\n\n    return function (attribute, index, posX, posY, posZ, emitterPosition, speed, speedSpread) {\n      v.copy(emitterPosition);\n      v.x -= posX;\n      v.y -= posY;\n      v.z -= posZ;\n      v.normalize().multiplyScalar(-this.randomFloat(speed, speedSpread));\n      attribute.typedArray.setVec3Components(index, v.x, v.y, v.z);\n    };\n  }(),\n  randomDirectionVector3OnDisc: function () {\n    'use strict';\n\n    var v = new THREE.Vector3();\n    /**\n     * Given an SPE.ShaderAttribute instance, create a direction vector from the given\n     * position, using `speed` as the magnitude. Values are saved to the attribute.\n     *\n     * @param  {Object} attribute       The instance of SPE.ShaderAttribute to save the result to.\n     * @param  {Number} index           The offset in the attribute's TypedArray to save the result from.\n     * @param  {Number} posX            The particle's x coordinate.\n     * @param  {Number} posY            The particle's y coordinate.\n     * @param  {Number} posZ            The particle's z coordinate.\n     * @param  {Object} emitterPosition THREE.Vector3 instance describing the emitter's base position.\n     * @param  {Number} speed           The magnitude to apply to the vector.\n     * @param  {Number} speedSpread     The amount of randomness to apply to the magnitude.\n     */\n\n    return function (attribute, index, posX, posY, posZ, emitterPosition, speed, speedSpread) {\n      v.copy(emitterPosition);\n      v.x -= posX;\n      v.y -= posY;\n      v.z -= posZ;\n      v.normalize().multiplyScalar(-this.randomFloat(speed, speedSpread));\n      attribute.typedArray.setVec3Components(index, v.x, v.y, 0);\n    };\n  }(),\n  getPackedRotationAxis: function () {\n    'use strict';\n\n    var v = new THREE.Vector3(),\n        vSpread = new THREE.Vector3(),\n        c = new THREE.Color(),\n        addOne = new THREE.Vector3(1, 1, 1);\n    /**\n     * Given a rotation axis, and a rotation axis spread vector,\n     * calculate a randomised rotation axis, and pack it into\n     * a hexadecimal value represented in decimal form.\n     * @param  {Object} axis       THREE.Vector3 instance describing the rotation axis.\n     * @param  {Object} axisSpread THREE.Vector3 instance describing the amount of randomness to apply to the rotation axis.\n     * @return {Number}            The packed rotation axis, with randomness.\n     */\n\n    return function (axis, axisSpread) {\n      v.copy(axis).normalize();\n      vSpread.copy(axisSpread).normalize();\n      v.x += -axisSpread.x * 0.5 + Math.random() * axisSpread.x;\n      v.y += -axisSpread.y * 0.5 + Math.random() * axisSpread.y;\n      v.z += -axisSpread.z * 0.5 + Math.random() * axisSpread.z; // v.x = Math.abs( v.x );\n      // v.y = Math.abs( v.y );\n      // v.z = Math.abs( v.z );\n\n      v.normalize().add(addOne).multiplyScalar(0.5);\n      c.setRGB(v.x, v.y, v.z);\n      return c.getHex();\n    };\n  }()\n};\n/**\n * An SPE.Group instance.\n * @typedef {Object} Group\n * @see SPE.Group\n */\n\n/**\n * A map of options to configure an SPE.Group instance.\n * @typedef {Object} GroupOptions\n *\n * @property {Object} texture An object describing the texture used by the group.\n *\n * @property {Object} texture.value An instance of THREE.Texture.\n *\n * @property {Object=} texture.frames A THREE.Vector2 instance describing the number\n *                                    of frames on the x- and y-axis of the given texture.\n *                                    If not provided, the texture will NOT be treated as\n *                                    a sprite-sheet and as such will NOT be animated.\n *\n * @property {Number} [texture.frameCount=texture.frames.x * texture.frames.y] The total number of frames in the sprite-sheet.\n *                                                                   Allows for sprite-sheets that don't fill the entire\n *                                                                   texture.\n *\n * @property {Number} texture.loop The number of loops through the sprite-sheet that should\n *                                 be performed over the course of a single particle's lifetime.\n *\n * @property {Number} fixedTimeStep If no `dt` (or `deltaTime`) value is passed to this group's\n *                                  `tick()` function, this number will be used to move the particle\n *                                  simulation forward. Value in SECONDS.\n *\n * @property {Boolean} hasPerspective Whether the distance a particle is from the camera should affect\n *                                    the particle's size.\n *\n * @property {Boolean} colorize Whether the particles in this group should be rendered with color, or\n *                              whether the only color of particles will come from the provided texture.\n *\n * @property {Number} blending One of Three.js's blending modes to apply to this group's `ShaderMaterial`.\n *\n * @property {Boolean} transparent Whether these particle's should be rendered with transparency.\n *\n * @property {Number} alphaTest Sets the alpha value to be used when running an alpha test on the `texture.value` property. Value between 0 and 1.\n *\n * @property {Boolean} depthWrite Whether rendering the group has any effect on the depth buffer.\n *\n * @property {Boolean} depthTest Whether to have depth test enabled when rendering this group.\n *\n * @property {Boolean} fog Whether this group's particles should be affected by their scene's fog.\n *\n * @property {Number} scale The scale factor to apply to this group's particle sizes. Useful for\n *                          setting particle sizes to be relative to renderer size.\n */\n\n/**\n * The SPE.Group class. Creates a new group, containing a material, geometry, and mesh.\n *\n * @constructor\n * @param {GroupOptions} options A map of options to configure the group instance.\n */\n\nSPE.Group = function (options) {\n  'use strict';\n\n  var utils = SPE.utils,\n      types = utils.types; // Ensure we have a map of options to play with\n\n  options = utils.ensureTypedArg(options, types.OBJECT, {});\n  options.texture = utils.ensureTypedArg(options.texture, types.OBJECT, {}); // Assign a UUID to this instance\n\n  this.uuid = THREE.Math.generateUUID(); // If no `deltaTime` value is passed to the `SPE.Group.tick` function,\n  // the value of this property will be used to advance the simulation.\n\n  this.fixedTimeStep = utils.ensureTypedArg(options.fixedTimeStep, types.NUMBER, 0.016); // Set properties used in the uniforms map, starting with the\n  // texture stuff.\n\n  this.texture = utils.ensureInstanceOf(options.texture.value, THREE.Texture, null);\n  this.textureFrames = utils.ensureInstanceOf(options.texture.frames, THREE.Vector2, new THREE.Vector2(1, 1));\n  this.textureFrameCount = utils.ensureTypedArg(options.texture.frameCount, types.NUMBER, this.textureFrames.x * this.textureFrames.y);\n  this.textureLoop = utils.ensureTypedArg(options.texture.loop, types.NUMBER, 1);\n  this.textureFrames.max(new THREE.Vector2(1, 1));\n  this.hasPerspective = utils.ensureTypedArg(options.hasPerspective, types.BOOLEAN, true);\n  this.colorize = utils.ensureTypedArg(options.colorize, types.BOOLEAN, true);\n  this.maxParticleCount = utils.ensureTypedArg(options.maxParticleCount, types.NUMBER, null); // Set properties used to define the ShaderMaterial's appearance.\n\n  this.blending = utils.ensureTypedArg(options.blending, types.NUMBER, THREE.AdditiveBlending);\n  this.transparent = utils.ensureTypedArg(options.transparent, types.BOOLEAN, true);\n  this.alphaTest = parseFloat(utils.ensureTypedArg(options.alphaTest, types.NUMBER, 0.0));\n  this.depthWrite = utils.ensureTypedArg(options.depthWrite, types.BOOLEAN, false);\n  this.depthTest = utils.ensureTypedArg(options.depthTest, types.BOOLEAN, true);\n  this.fog = utils.ensureTypedArg(options.fog, types.BOOLEAN, true);\n  this.scale = utils.ensureTypedArg(options.scale, types.NUMBER, 300); // Where emitter's go to curl up in a warm blanket and live\n  // out their days.\n\n  this.emitters = [];\n  this.emitterIDs = []; // Create properties for use by the emitter pooling functions.\n\n  this._pool = [];\n  this._poolCreationSettings = null;\n  this._createNewWhenPoolEmpty = 0; // Whether all attributes should be forced to updated\n  // their entire buffer contents on the next tick.\n  //\n  // Used when an emitter is removed.\n\n  this._attributesNeedRefresh = false;\n  this._attributesNeedDynamicReset = false;\n  this.particleCount = 0; // Map of uniforms to be applied to the ShaderMaterial instance.\n\n  this.uniforms = {\n    texture: {\n      type: 't',\n      value: this.texture\n    },\n    textureAnimation: {\n      type: 'v4',\n      value: new THREE.Vector4(this.textureFrames.x, this.textureFrames.y, this.textureFrameCount, Math.max(Math.abs(this.textureLoop), 1.0))\n    },\n    fogColor: {\n      type: 'c',\n      value: null\n    },\n    fogNear: {\n      type: 'f',\n      value: 10\n    },\n    fogFar: {\n      type: 'f',\n      value: 200\n    },\n    fogDensity: {\n      type: 'f',\n      value: 0.5\n    },\n    deltaTime: {\n      type: 'f',\n      value: 0\n    },\n    runTime: {\n      type: 'f',\n      value: 0\n    },\n    scale: {\n      type: 'f',\n      value: this.scale\n    }\n  }; // Add some defines into the mix...\n\n  this.defines = {\n    HAS_PERSPECTIVE: this.hasPerspective,\n    COLORIZE: this.colorize,\n    VALUE_OVER_LIFETIME_LENGTH: SPE.valueOverLifetimeLength,\n    SHOULD_ROTATE_TEXTURE: false,\n    SHOULD_ROTATE_PARTICLES: false,\n    SHOULD_WIGGLE_PARTICLES: false,\n    SHOULD_CALCULATE_SPRITE: this.textureFrames.x > 1 || this.textureFrames.y > 1\n  }; // Map of all attributes to be applied to the particles.\n  //\n  // See SPE.ShaderAttribute for a bit more info on this bit.\n\n  this.attributes = {\n    position: new SPE.ShaderAttribute('v3', true),\n    acceleration: new SPE.ShaderAttribute('v4', true),\n    // w component is drag\n    velocity: new SPE.ShaderAttribute('v3', true),\n    rotation: new SPE.ShaderAttribute('v4', true),\n    rotationCenter: new SPE.ShaderAttribute('v3', true),\n    params: new SPE.ShaderAttribute('v4', true),\n    // Holds (alive, age, delay, wiggle)\n    size: new SPE.ShaderAttribute('v4', true),\n    angle: new SPE.ShaderAttribute('v4', true),\n    color: new SPE.ShaderAttribute('v4', true),\n    opacity: new SPE.ShaderAttribute('v4', true)\n  };\n  this.attributeKeys = Object.keys(this.attributes);\n  this.attributeCount = this.attributeKeys.length; // Create the ShaderMaterial instance that'll help render the\n  // particles.\n\n  this.material = new THREE.ShaderMaterial({\n    uniforms: this.uniforms,\n    vertexShader: SPE.shaders.vertex,\n    fragmentShader: SPE.shaders.fragment,\n    blending: this.blending,\n    transparent: this.transparent,\n    alphaTest: this.alphaTest,\n    depthWrite: this.depthWrite,\n    depthTest: this.depthTest,\n    defines: this.defines,\n    fog: this.fog\n  }); // Create the BufferGeometry and Points instances, ensuring\n  // the geometry and material are given to the latter.\n\n  this.geometry = new THREE.BufferGeometry();\n  this.mesh = new THREE.Points(this.geometry, this.material);\n\n  if (this.maxParticleCount === null) {\n    console.warn('SPE.Group: No maxParticleCount specified. Adding emitters after rendering will probably cause errors.');\n  }\n};\n\nSPE.Group.constructor = SPE.Group;\n\nSPE.Group.prototype._updateDefines = function () {\n  'use strict';\n\n  var emitters = this.emitters,\n      i = emitters.length - 1,\n      emitter,\n      defines = this.defines;\n\n  for (i; i >= 0; --i) {\n    emitter = emitters[i]; // Only do angle calculation if there's no spritesheet defined.\n    //\n    // Saves calculations being done and then overwritten in the shaders.\n\n    if (!defines.SHOULD_CALCULATE_SPRITE) {\n      defines.SHOULD_ROTATE_TEXTURE = defines.SHOULD_ROTATE_TEXTURE || !!Math.max(Math.max.apply(null, emitter.angle.value), Math.max.apply(null, emitter.angle.spread));\n    }\n\n    defines.SHOULD_ROTATE_PARTICLES = defines.SHOULD_ROTATE_PARTICLES || !!Math.max(emitter.rotation.angle, emitter.rotation.angleSpread);\n    defines.SHOULD_WIGGLE_PARTICLES = defines.SHOULD_WIGGLE_PARTICLES || !!Math.max(emitter.wiggle.value, emitter.wiggle.spread);\n  }\n\n  this.material.needsUpdate = true;\n};\n\nSPE.Group.prototype._applyAttributesToGeometry = function () {\n  'use strict';\n\n  var attributes = this.attributes,\n      geometry = this.geometry,\n      geometryAttributes = geometry.attributes,\n      attribute,\n      geometryAttribute; // Loop through all the shader attributes and assign (or re-assign)\n  // typed array buffers to each one.\n\n  for (var attr in attributes) {\n    if (attributes.hasOwnProperty(attr)) {\n      attribute = attributes[attr];\n      geometryAttribute = geometryAttributes[attr]; // Update the array if this attribute exists on the geometry.\n      //\n      // This needs to be done because the attribute's typed array might have\n      // been resized and reinstantiated, and might now be looking at a\n      // different ArrayBuffer, so reference needs updating.\n\n      if (geometryAttribute) {\n        geometryAttribute.array = attribute.typedArray.array;\n      } // // Add the attribute to the geometry if it doesn't already exist.\n      else {\n          geometry.addAttribute(attr, attribute.bufferAttribute);\n        } // Mark the attribute as needing an update the next time a frame is rendered.\n\n\n      attribute.bufferAttribute.needsUpdate = true;\n    }\n  } // Mark the draw range on the geometry. This will ensure\n  // only the values in the attribute buffers that are\n  // associated with a particle will be used in THREE's\n  // render cycle.\n\n\n  this.geometry.setDrawRange(0, this.particleCount);\n};\n/**\n * Adds an SPE.Emitter instance to this group, creating particle values and\n * assigning them to this group's shader attributes.\n *\n * @param {Emitter} emitter The emitter to add to this group.\n */\n\n\nSPE.Group.prototype.addEmitter = function (emitter) {\n  'use strict'; // Ensure an actual emitter instance is passed here.\n  //\n  // Decided not to throw here, just in case a scene's\n  // rendering would be paused. Logging an error instead\n  // of stopping execution if exceptions aren't caught.\n\n  if (emitter instanceof SPE.Emitter === false) {\n    console.error('`emitter` argument must be instance of SPE.Emitter. Was provided with:', emitter);\n    return;\n  } // If the emitter already exists as a member of this group, then\n  // stop here, we don't want to add it again.\n  else if (this.emitterIDs.indexOf(emitter.uuid) > -1) {\n      console.error('Emitter already exists in this group. Will not add again.');\n      return;\n    } // And finally, if the emitter is a member of another group,\n    // don't add it to this group.\n    else if (emitter.group !== null) {\n        console.error('Emitter already belongs to another group. Will not add to requested group.');\n        return;\n      }\n\n  var attributes = this.attributes,\n      start = this.particleCount,\n      end = start + emitter.particleCount; // Update this group's particle count.\n\n  this.particleCount = end; // Emit a warning if the emitter being added will exceed the buffer sizes specified.\n\n  if (this.maxParticleCount !== null && this.particleCount > this.maxParticleCount) {\n    console.warn('SPE.Group: maxParticleCount exceeded. Requesting', this.particleCount, 'particles, can support only', this.maxParticleCount);\n  } // Set the `particlesPerSecond` value (PPS) on the emitter.\n  // It's used to determine how many particles to release\n  // on a per-frame basis.\n\n\n  emitter._calculatePPSValue(emitter.maxAge._value + emitter.maxAge._spread);\n\n  emitter._setBufferUpdateRanges(this.attributeKeys); // Store the offset value in the TypedArray attributes for this emitter.\n\n\n  emitter._setAttributeOffset(start); // Save a reference to this group on the emitter so it knows\n  // where it belongs.\n\n\n  emitter.group = this; // Store reference to the attributes on the emitter for\n  // easier access during the emitter's tick function.\n\n  emitter.attributes = this.attributes; // Ensure the attributes and their BufferAttributes exist, and their\n  // TypedArrays are of the correct size.\n\n  for (var attr in attributes) {\n    if (attributes.hasOwnProperty(attr)) {\n      // When creating a buffer, pass through the maxParticle count\n      // if one is specified.\n      attributes[attr]._createBufferAttribute(this.maxParticleCount !== null ? this.maxParticleCount : this.particleCount);\n    }\n  } // Loop through each particle this emitter wants to have, and create the attributes values,\n  // storing them in the TypedArrays that each attribute holds.\n\n\n  for (var i = start; i < end; ++i) {\n    emitter._assignPositionValue(i);\n\n    emitter._assignForceValue(i, 'velocity');\n\n    emitter._assignForceValue(i, 'acceleration');\n\n    emitter._assignAbsLifetimeValue(i, 'opacity');\n\n    emitter._assignAbsLifetimeValue(i, 'size');\n\n    emitter._assignAngleValue(i);\n\n    emitter._assignRotationValue(i);\n\n    emitter._assignParamsValue(i);\n\n    emitter._assignColorValue(i);\n  } // Update the geometry and make sure the attributes are referencing\n  // the typed arrays properly.\n\n\n  this._applyAttributesToGeometry(); // Store this emitter in this group's emitter's store.\n\n\n  this.emitters.push(emitter);\n  this.emitterIDs.push(emitter.uuid); // Update certain flags to enable shader calculations only if they're necessary.\n\n  this._updateDefines(emitter); // Update the material since defines might have changed\n\n\n  this.material.needsUpdate = true;\n  this.geometry.needsUpdate = true;\n  this._attributesNeedRefresh = true; // Return the group to enable chaining.\n\n  return this;\n};\n/**\n * Removes an SPE.Emitter instance from this group. When called,\n * all particle's belonging to the given emitter will be instantly\n * removed from the scene.\n *\n * @param {Emitter} emitter The emitter to add to this group.\n */\n\n\nSPE.Group.prototype.removeEmitter = function (emitter) {\n  'use strict';\n\n  var emitterIndex = this.emitterIDs.indexOf(emitter.uuid); // Ensure an actual emitter instance is passed here.\n  //\n  // Decided not to throw here, just in case a scene's\n  // rendering would be paused. Logging an error instead\n  // of stopping execution if exceptions aren't caught.\n\n  if (emitter instanceof SPE.Emitter === false) {\n    console.error('`emitter` argument must be instance of SPE.Emitter. Was provided with:', emitter);\n    return;\n  } // Issue an error if the emitter isn't a member of this group.\n  else if (emitterIndex === -1) {\n      console.error('Emitter does not exist in this group. Will not remove.');\n      return;\n    } // Kill all particles by marking them as dead\n  // and their age as 0.\n\n\n  var start = emitter.attributeOffset,\n      end = start + emitter.particleCount,\n      params = this.attributes.params.typedArray; // Set alive and age to zero.\n\n  for (var i = start; i < end; ++i) {\n    params.array[i * 4] = 0.0;\n    params.array[i * 4 + 1] = 0.0;\n  } // Remove the emitter from this group's \"store\".\n\n\n  this.emitters.splice(emitterIndex, 1);\n  this.emitterIDs.splice(emitterIndex, 1); // Remove this emitter's attribute values from all shader attributes.\n  // The `.splice()` call here also marks each attribute's buffer\n  // as needing to update it's entire contents.\n\n  for (var attr in this.attributes) {\n    if (this.attributes.hasOwnProperty(attr)) {\n      this.attributes[attr].splice(start, end);\n    }\n  } // Ensure this group's particle count is correct.\n\n\n  this.particleCount -= emitter.particleCount; // Call the emitter's remove method.\n\n  emitter._onRemove(); // Set a flag to indicate that the attribute buffers should\n  // be updated in their entirety on the next frame.\n\n\n  this._attributesNeedRefresh = true;\n};\n/**\n * Fetch a single emitter instance from the pool.\n * If there are no objects in the pool, a new emitter will be\n * created if specified.\n *\n * @return {Emitter|null}\n */\n\n\nSPE.Group.prototype.getFromPool = function () {\n  'use strict';\n\n  var pool = this._pool,\n      createNew = this._createNewWhenPoolEmpty;\n\n  if (pool.length) {\n    return pool.pop();\n  } else if (createNew) {\n    return new SPE.Emitter(this._poolCreationSettings);\n  }\n\n  return null;\n};\n/**\n * Release an emitter into the pool.\n *\n * @param  {ShaderParticleEmitter} emitter\n * @return {Group} This group instance.\n */\n\n\nSPE.Group.prototype.releaseIntoPool = function (emitter) {\n  'use strict';\n\n  if (emitter instanceof SPE.Emitter === false) {\n    console.error('Argument is not instanceof SPE.Emitter:', emitter);\n    return;\n  }\n\n  emitter.reset();\n\n  this._pool.unshift(emitter);\n\n  return this;\n};\n/**\n * Get the pool array\n *\n * @return {Array}\n */\n\n\nSPE.Group.prototype.getPool = function () {\n  'use strict';\n\n  return this._pool;\n};\n/**\n * Add a pool of emitters to this particle group\n *\n * @param {Number} numEmitters      The number of emitters to add to the pool.\n * @param {EmitterOptions|Array} emitterOptions  An object, or array of objects, describing the options to pass to each emitter.\n * @param {Boolean} createNew       Should a new emitter be created if the pool runs out?\n * @return {Group} This group instance.\n */\n\n\nSPE.Group.prototype.addPool = function (numEmitters, emitterOptions, createNew) {\n  'use strict';\n\n  var emitter; // Save relevant settings and flags.\n\n  this._poolCreationSettings = emitterOptions;\n  this._createNewWhenPoolEmpty = !!createNew; // Create the emitters, add them to this group and the pool.\n\n  for (var i = 0; i < numEmitters; ++i) {\n    if (Array.isArray(emitterOptions)) {\n      emitter = new SPE.Emitter(emitterOptions[i]);\n    } else {\n      emitter = new SPE.Emitter(emitterOptions);\n    }\n\n    this.addEmitter(emitter);\n    this.releaseIntoPool(emitter);\n  }\n\n  return this;\n};\n\nSPE.Group.prototype._triggerSingleEmitter = function (pos) {\n  'use strict';\n\n  var emitter = this.getFromPool(),\n      self = this;\n\n  if (emitter === null) {\n    console.log('SPE.Group pool ran out.');\n    return;\n  } // TODO:\n  // - Make sure buffers are update with thus new position.\n\n\n  if (pos instanceof THREE.Vector3) {\n    emitter.position.value.copy(pos); // Trigger the setter for this property to force an\n    // update to the emitter's position attribute.\n\n    emitter.position.value = emitter.position.value;\n  }\n\n  emitter.enable();\n  setTimeout(function () {\n    emitter.disable();\n    self.releaseIntoPool(emitter);\n  }, Math.max(emitter.duration, emitter.maxAge.value + emitter.maxAge.spread) * 1000);\n  return this;\n};\n/**\n * Set a given number of emitters as alive, with an optional position\n * vector3 to move them to.\n *\n * @param  {Number} numEmitters The number of emitters to activate\n * @param  {Object} [position=undefined] A THREE.Vector3 instance describing the position to activate the emitter(s) at.\n * @return {Group} This group instance.\n */\n\n\nSPE.Group.prototype.triggerPoolEmitter = function (numEmitters, position) {\n  'use strict';\n\n  if (typeof numEmitters === 'number' && numEmitters > 1) {\n    for (var i = 0; i < numEmitters; ++i) {\n      this._triggerSingleEmitter(position);\n    }\n  } else {\n    this._triggerSingleEmitter(position);\n  }\n\n  return this;\n};\n\nSPE.Group.prototype._updateUniforms = function (dt) {\n  'use strict';\n\n  this.uniforms.runTime.value += dt;\n  this.uniforms.deltaTime.value = dt;\n};\n\nSPE.Group.prototype._resetBufferRanges = function () {\n  'use strict';\n\n  var keys = this.attributeKeys,\n      i = this.attributeCount - 1,\n      attrs = this.attributes;\n\n  for (i; i >= 0; --i) {\n    attrs[keys[i]].resetUpdateRange();\n  }\n};\n\nSPE.Group.prototype._updateBuffers = function (emitter) {\n  'use strict';\n\n  var keys = this.attributeKeys,\n      i = this.attributeCount - 1,\n      attrs = this.attributes,\n      emitterRanges = emitter.bufferUpdateRanges,\n      key,\n      emitterAttr,\n      attr;\n\n  for (i; i >= 0; --i) {\n    key = keys[i];\n    emitterAttr = emitterRanges[key];\n    attr = attrs[key];\n    attr.setUpdateRange(emitterAttr.min, emitterAttr.max);\n    attr.flagUpdate();\n  }\n};\n/**\n * Simulate all the emitter's belonging to this group, updating\n * attribute values along the way.\n * @param  {Number} [dt=Group's `fixedTimeStep` value] The number of seconds to simulate the group's emitters for (deltaTime)\n */\n\n\nSPE.Group.prototype.tick = function (dt) {\n  'use strict';\n\n  var emitters = this.emitters,\n      numEmitters = emitters.length,\n      deltaTime = dt || this.fixedTimeStep,\n      keys = this.attributeKeys,\n      i,\n      attrs = this.attributes; // Update uniform values.\n\n  this._updateUniforms(deltaTime); // Reset buffer update ranges on the shader attributes.\n\n\n  this._resetBufferRanges(); // If nothing needs updating, then stop here.\n\n\n  if (numEmitters === 0 && this._attributesNeedRefresh === false && this._attributesNeedDynamicReset === false) {\n    return;\n  } // Loop through each emitter in this group and\n  // simulate it, then update the shader attribute\n  // buffers.\n\n\n  for (var i = 0, emitter; i < numEmitters; ++i) {\n    emitter = emitters[i];\n    emitter.tick(deltaTime);\n\n    this._updateBuffers(emitter);\n  } // If the shader attributes have been refreshed,\n  // then the dynamic properties of each buffer\n  // attribute will need to be reset back to\n  // what they should be.\n\n\n  if (this._attributesNeedDynamicReset === true) {\n    i = this.attributeCount - 1;\n\n    for (i; i >= 0; --i) {\n      attrs[keys[i]].resetDynamic();\n    }\n\n    this._attributesNeedDynamicReset = false;\n  } // If this group's shader attributes need a full refresh\n  // then mark each attribute's buffer attribute as\n  // needing so.\n\n\n  if (this._attributesNeedRefresh === true) {\n    i = this.attributeCount - 1;\n\n    for (i; i >= 0; --i) {\n      attrs[keys[i]].forceUpdateAll();\n    }\n\n    this._attributesNeedRefresh = false;\n    this._attributesNeedDynamicReset = true;\n  }\n};\n/**\n * Dipose the geometry and material for the group.\n *\n * @return {Group} Group instance.\n */\n\n\nSPE.Group.prototype.dispose = function () {\n  'use strict';\n\n  this.geometry.dispose();\n  this.material.dispose();\n  return this;\n};\n/**\n * An SPE.Emitter instance.\n * @typedef {Object} Emitter\n * @see SPE.Emitter\n */\n\n/**\n * A map of options to configure an SPE.Emitter instance.\n *\n * @typedef {Object} EmitterOptions\n *\n * @property {distribution} [type=BOX] The default distribution this emitter should use to control\n *                         its particle's spawn position and force behaviour.\n *                         Must be an SPE.distributions.* value.\n *\n *\n * @property {Number} [particleCount=100] The total number of particles this emitter will hold. NOTE: this is not the number\n *                                  of particles emitted in a second, or anything like that. The number of particles\n *                                  emitted per-second is calculated by particleCount / maxAge (approximately!)\n *\n * @property {Number|null} [duration=null] The duration in seconds that this emitter should live for. If not specified, the emitter\n *                                         will emit particles indefinitely.\n *                                         NOTE: When an emitter is older than a specified duration, the emitter is NOT removed from\n *                                         it's group, but rather is just marked as dead, allowing it to be reanimated at a later time\n *                                         using `SPE.Emitter.prototype.enable()`.\n *\n * @property {Boolean} [isStatic=false] Whether this emitter should be not be simulated (true).\n * @property {Boolean} [activeMultiplier=1] A value between 0 and 1 describing what percentage of this emitter's particlesPerSecond should be\n *                                          emitted, where 0 is 0%, and 1 is 100%.\n *                                          For example, having an emitter with 100 particles, a maxAge of 2, yields a particlesPerSecond\n *                                          value of 50. Setting `activeMultiplier` to 0.5, then, will only emit 25 particles per second (0.5 = 50%).\n *                                          Values greater than 1 will emulate a burst of particles, causing the emitter to run out of particles\n *                                          before it's next activation cycle.\n *\n * @property {Boolean} [direction=1] The direction of the emitter. If value is `1`, emitter will start at beginning of particle's lifecycle.\n *                                   If value is `-1`, emitter will start at end of particle's lifecycle and work it's way backwards.\n *\n * @property {Object} [maxAge={}] An object describing the particle's maximum age in seconds.\n * @property {Number} [maxAge.value=2] A number between 0 and 1 describing the amount of maxAge to apply to all particles.\n * @property {Number} [maxAge.spread=0] A number describing the maxAge variance on a per-particle basis.\n *\n *\n * @property {Object} [position={}] An object describing this emitter's position.\n * @property {Object} [position.value=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's base position.\n * @property {Object} [position.spread=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's position variance on a per-particle basis.\n *                                                          Note that when using a SPHERE or DISC distribution, only the x-component\n *                                                          of this vector is used.\n * @property {Object} [position.spreadClamp=new THREE.Vector3()] A THREE.Vector3 instance describing the numeric multiples the particle's should\n *                                                               be spread out over.\n *                                                               Note that when using a SPHERE or DISC distribution, only the x-component\n *                                                               of this vector is used.\n * @property {Number} [position.radius=10] This emitter's base radius.\n * @property {Object} [position.radiusScale=new THREE.Vector3()] A THREE.Vector3 instance describing the radius's scale in all three axes. Allows a SPHERE or DISC to be squashed or stretched.\n * @property {distribution} [position.distribution=value of the `type` option.] A specific distribution to use when radiusing particles. Overrides the `type` option.\n * @property {Boolean} [position.randomise=false] When a particle is re-spawned, whether it's position should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [velocity={}] An object describing this particle velocity.\n * @property {Object} [velocity.value=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's base velocity.\n * @property {Object} [velocity.spread=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's velocity variance on a per-particle basis.\n *                                                          Note that when using a SPHERE or DISC distribution, only the x-component\n *                                                          of this vector is used.\n * @property {distribution} [velocity.distribution=value of the `type` option.] A specific distribution to use when calculating a particle's velocity. Overrides the `type` option.\n * @property {Boolean} [velocity.randomise=false] When a particle is re-spawned, whether it's velocity should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [acceleration={}] An object describing this particle's acceleration.\n * @property {Object} [acceleration.value=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's base acceleration.\n * @property {Object} [acceleration.spread=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's acceleration variance on a per-particle basis.\n *                           Note that when using a SPHERE or DISC distribution, only the x-component\n *                           of this vector is used.\n * @property {distribution} [acceleration.distribution=value of the `type` option.] A specific distribution to use when calculating a particle's acceleration. Overrides the `type` option.\n * @property {Boolean} [acceleration.randomise=false] When a particle is re-spawned, whether it's acceleration should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [drag={}] An object describing this particle drag. Drag is applied to both velocity and acceleration values.\n * @property {Number} [drag.value=0] A number between 0 and 1 describing the amount of drag to apply to all particles.\n * @property {Number} [drag.spread=0] A number describing the drag variance on a per-particle basis.\n * @property {Boolean} [drag.randomise=false] When a particle is re-spawned, whether it's drag should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [wiggle={}] This is quite a fun one! The values of this object will determine whether a particle will wiggle, or jiggle, or wave,\n *                                or shimmy, or waggle, or... Well you get the idea. The wiggle is calculated over-time, meaning that a particle will\n *                                start off with no wiggle, and end up wiggling about with the distance of the `value` specified by the time it dies.\n *                                It's quite handy to simulate fire embers, or similar effects where the particle's position should slightly change over\n *                                time, and such change isn't easily controlled by rotation, velocity, or acceleration. The wiggle is a combination of sin and cos calculations, so is circular in nature.\n * @property {Number} [wiggle.value=0] A number describing the amount of wiggle to apply to all particles. It's measured in distance.\n * @property {Number} [wiggle.spread=0] A number describing the wiggle variance on a per-particle basis.\n *\n *\n * @property {Object} [rotation={}] An object describing this emitter's rotation. It can either be static, or set to rotate from 0radians to the value of `rotation.value`\n *                                  over a particle's lifetime. Rotation values affect both a particle's position and the forces applied to it.\n * @property {Object} [rotation.axis=new THREE.Vector3(0, 1, 0)] A THREE.Vector3 instance describing this emitter's axis of rotation.\n * @property {Object} [rotation.axisSpread=new THREE.Vector3()] A THREE.Vector3 instance describing the amount of variance to apply to the axis of rotation on\n *                                                              a per-particle basis.\n * @property {Number} [rotation.angle=0] The angle of rotation, given in radians. If `rotation.static` is true, the emitter will start off rotated at this angle, and stay as such.\n *                                       Otherwise, the particles will rotate from 0radians to this value over their lifetimes.\n * @property {Number} [rotation.angleSpread=0] The amount of variance in each particle's rotation angle.\n * @property {Boolean} [rotation.static=false] Whether the rotation should be static or not.\n * @property {Object} [rotation.center=The value of `position.value`] A THREE.Vector3 instance describing the center point of rotation.\n * @property {Boolean} [rotation.randomise=false] When a particle is re-spawned, whether it's rotation should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [color={}] An object describing a particle's color. This property is a \"value-over-lifetime\" property, meaning an array of values and spreads can be\n *                               given to describe specific value changes over a particle's lifetime.\n *                               Depending on the value of SPE.valueOverLifetimeLength, if arrays of THREE.Color instances are given, then the array will be interpolated to\n *                               have a length matching the value of SPE.valueOverLifetimeLength.\n * @property {Object} [color.value=new THREE.Color()] Either a single THREE.Color instance, or an array of THREE.Color instances to describe the color of a particle over it's lifetime.\n * @property {Object} [color.spread=new THREE.Vector3()] Either a single THREE.Vector3 instance, or an array of THREE.Vector3 instances to describe the color variance of a particle over it's lifetime.\n * @property {Boolean} [color.randomise=false] When a particle is re-spawned, whether it's color should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [opacity={}] An object describing a particle's opacity. This property is a \"value-over-lifetime\" property, meaning an array of values and spreads can be\n *                               given to describe specific value changes over a particle's lifetime.\n *                               Depending on the value of SPE.valueOverLifetimeLength, if arrays of numbers are given, then the array will be interpolated to\n *                               have a length matching the value of SPE.valueOverLifetimeLength.\n * @property {Number} [opacity.value=1] Either a single number, or an array of numbers to describe the opacity of a particle over it's lifetime.\n * @property {Number} [opacity.spread=0] Either a single number, or an array of numbers to describe the opacity variance of a particle over it's lifetime.\n * @property {Boolean} [opacity.randomise=false] When a particle is re-spawned, whether it's opacity should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [size={}] An object describing a particle's size. This property is a \"value-over-lifetime\" property, meaning an array of values and spreads can be\n *                               given to describe specific value changes over a particle's lifetime.\n *                               Depending on the value of SPE.valueOverLifetimeLength, if arrays of numbers are given, then the array will be interpolated to\n *                               have a length matching the value of SPE.valueOverLifetimeLength.\n * @property {Number} [size.value=1] Either a single number, or an array of numbers to describe the size of a particle over it's lifetime.\n * @property {Number} [size.spread=0] Either a single number, or an array of numbers to describe the size variance of a particle over it's lifetime.\n * @property {Boolean} [size.randomise=false] When a particle is re-spawned, whether it's size should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [angle={}] An object describing a particle's angle. The angle is a 2d-rotation, measured in radians, applied to the particle's texture.\n *                               NOTE: if a particle's texture is a sprite-sheet, this value IS IGNORED.\n *                               This property is a \"value-over-lifetime\" property, meaning an array of values and spreads can be\n *                               given to describe specific value changes over a particle's lifetime.\n *                               Depending on the value of SPE.valueOverLifetimeLength, if arrays of numbers are given, then the array will be interpolated to\n *                               have a length matching the value of SPE.valueOverLifetimeLength.\n * @property {Number} [angle.value=0] Either a single number, or an array of numbers to describe the angle of a particle over it's lifetime.\n * @property {Number} [angle.spread=0] Either a single number, or an array of numbers to describe the angle variance of a particle over it's lifetime.\n * @property {Boolean} [angle.randomise=false] When a particle is re-spawned, whether it's angle should be re-randomised or not. Can incur a performance hit.\n *\n */\n\n/**\n * The SPE.Emitter class.\n *\n * @constructor\n *\n * @param {EmitterOptions} options A map of options to configure the emitter.\n */\n\n\nSPE.Emitter = function (options) {\n  'use strict';\n\n  var utils = SPE.utils,\n      types = utils.types,\n      lifetimeLength = SPE.valueOverLifetimeLength; // Ensure we have a map of options to play with,\n  // and that each option is in the correct format.\n\n  options = utils.ensureTypedArg(options, types.OBJECT, {});\n  options.position = utils.ensureTypedArg(options.position, types.OBJECT, {});\n  options.velocity = utils.ensureTypedArg(options.velocity, types.OBJECT, {});\n  options.acceleration = utils.ensureTypedArg(options.acceleration, types.OBJECT, {});\n  options.radius = utils.ensureTypedArg(options.radius, types.OBJECT, {});\n  options.drag = utils.ensureTypedArg(options.drag, types.OBJECT, {});\n  options.rotation = utils.ensureTypedArg(options.rotation, types.OBJECT, {});\n  options.color = utils.ensureTypedArg(options.color, types.OBJECT, {});\n  options.opacity = utils.ensureTypedArg(options.opacity, types.OBJECT, {});\n  options.size = utils.ensureTypedArg(options.size, types.OBJECT, {});\n  options.angle = utils.ensureTypedArg(options.angle, types.OBJECT, {});\n  options.wiggle = utils.ensureTypedArg(options.wiggle, types.OBJECT, {});\n  options.maxAge = utils.ensureTypedArg(options.maxAge, types.OBJECT, {});\n\n  if (options.onParticleSpawn) {\n    console.warn('onParticleSpawn has been removed. Please set properties directly to alter values at runtime.');\n  }\n\n  this.uuid = THREE.Math.generateUUID();\n  this.type = utils.ensureTypedArg(options.type, types.NUMBER, SPE.distributions.BOX); // Start assigning properties...kicking it off with props that DON'T support values over\n  // lifetimes.\n  //\n  // Btw, values over lifetimes are just the new way of referring to *Start, *Middle, and *End.\n\n  this.position = {\n    _value: utils.ensureInstanceOf(options.position.value, THREE.Vector3, new THREE.Vector3()),\n    _spread: utils.ensureInstanceOf(options.position.spread, THREE.Vector3, new THREE.Vector3()),\n    _spreadClamp: utils.ensureInstanceOf(options.position.spreadClamp, THREE.Vector3, new THREE.Vector3()),\n    _distribution: utils.ensureTypedArg(options.position.distribution, types.NUMBER, this.type),\n    _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false),\n    _radius: utils.ensureTypedArg(options.position.radius, types.NUMBER, 10),\n    _radiusScale: utils.ensureInstanceOf(options.position.radiusScale, THREE.Vector3, new THREE.Vector3(1, 1, 1)),\n    _distributionClamp: utils.ensureTypedArg(options.position.distributionClamp, types.NUMBER, 0)\n  };\n  this.velocity = {\n    _value: utils.ensureInstanceOf(options.velocity.value, THREE.Vector3, new THREE.Vector3()),\n    _spread: utils.ensureInstanceOf(options.velocity.spread, THREE.Vector3, new THREE.Vector3()),\n    _distribution: utils.ensureTypedArg(options.velocity.distribution, types.NUMBER, this.type),\n    _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false)\n  };\n  this.acceleration = {\n    _value: utils.ensureInstanceOf(options.acceleration.value, THREE.Vector3, new THREE.Vector3()),\n    _spread: utils.ensureInstanceOf(options.acceleration.spread, THREE.Vector3, new THREE.Vector3()),\n    _distribution: utils.ensureTypedArg(options.acceleration.distribution, types.NUMBER, this.type),\n    _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false)\n  };\n  this.drag = {\n    _value: utils.ensureTypedArg(options.drag.value, types.NUMBER, 0),\n    _spread: utils.ensureTypedArg(options.drag.spread, types.NUMBER, 0),\n    _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false)\n  };\n  this.wiggle = {\n    _value: utils.ensureTypedArg(options.wiggle.value, types.NUMBER, 0),\n    _spread: utils.ensureTypedArg(options.wiggle.spread, types.NUMBER, 0)\n  };\n  this.rotation = {\n    _axis: utils.ensureInstanceOf(options.rotation.axis, THREE.Vector3, new THREE.Vector3(0.0, 1.0, 0.0)),\n    _axisSpread: utils.ensureInstanceOf(options.rotation.axisSpread, THREE.Vector3, new THREE.Vector3()),\n    _angle: utils.ensureTypedArg(options.rotation.angle, types.NUMBER, 0),\n    _angleSpread: utils.ensureTypedArg(options.rotation.angleSpread, types.NUMBER, 0),\n    _static: utils.ensureTypedArg(options.rotation.static, types.BOOLEAN, false),\n    _center: utils.ensureInstanceOf(options.rotation.center, THREE.Vector3, this.position._value.clone()),\n    _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false)\n  };\n  this.maxAge = {\n    _value: utils.ensureTypedArg(options.maxAge.value, types.NUMBER, 2),\n    _spread: utils.ensureTypedArg(options.maxAge.spread, types.NUMBER, 0)\n  }; // The following properties can support either single values, or an array of values that change\n  // the property over a particle's lifetime (value over lifetime).\n\n  this.color = {\n    _value: utils.ensureArrayInstanceOf(options.color.value, THREE.Color, new THREE.Color()),\n    _spread: utils.ensureArrayInstanceOf(options.color.spread, THREE.Vector3, new THREE.Vector3()),\n    _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false)\n  };\n  this.opacity = {\n    _value: utils.ensureArrayTypedArg(options.opacity.value, types.NUMBER, 1),\n    _spread: utils.ensureArrayTypedArg(options.opacity.spread, types.NUMBER, 0),\n    _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false)\n  };\n  this.size = {\n    _value: utils.ensureArrayTypedArg(options.size.value, types.NUMBER, 1),\n    _spread: utils.ensureArrayTypedArg(options.size.spread, types.NUMBER, 0),\n    _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false)\n  };\n  this.angle = {\n    _value: utils.ensureArrayTypedArg(options.angle.value, types.NUMBER, 0),\n    _spread: utils.ensureArrayTypedArg(options.angle.spread, types.NUMBER, 0),\n    _randomise: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false)\n  }; // Assign renaining option values.\n\n  this.particleCount = utils.ensureTypedArg(options.particleCount, types.NUMBER, 100);\n  this.duration = utils.ensureTypedArg(options.duration, types.NUMBER, null);\n  this.isStatic = utils.ensureTypedArg(options.isStatic, types.BOOLEAN, false);\n  this.activeMultiplier = utils.ensureTypedArg(options.activeMultiplier, types.NUMBER, 1);\n  this.direction = utils.ensureTypedArg(options.direction, types.NUMBER, 1); // Whether this emitter is alive or not.\n\n  this.alive = utils.ensureTypedArg(options.alive, types.BOOLEAN, true); // The following properties are set internally and are not\n  // user-controllable.\n\n  this.particlesPerSecond = 0; // The current particle index for which particles should\n  // be marked as active on the next update cycle.\n\n  this.activationIndex = 0; // The offset in the typed arrays this emitter's\n  // particle's values will start at\n\n  this.attributeOffset = 0; // The end of the range in the attribute buffers\n\n  this.attributeEnd = 0; // Holds the time the emitter has been alive for.\n\n  this.age = 0.0; // Holds the number of currently-alive particles\n\n  this.activeParticleCount = 0.0; // Holds a reference to this emitter's group once\n  // it's added to one.\n\n  this.group = null; // Holds a reference to this emitter's group's attributes object\n  // for easier access.\n\n  this.attributes = null; // Holds a reference to the params attribute's typed array\n  // for quicker access.\n\n  this.paramsArray = null; // A set of flags to determine whether particular properties\n  // should be re-randomised when a particle is reset.\n  //\n  // If a `randomise` property is given, this is preferred.\n  // Otherwise, it looks at whether a spread value has been\n  // given.\n  //\n  // It allows randomization to be turned off as desired. If\n  // all randomization is turned off, then I'd expect a performance\n  // boost as no attribute buffers (excluding the `params`)\n  // would have to be re-passed to the GPU each frame (since nothing\n  // except the `params` attribute would have changed).\n\n  this.resetFlags = {\n    // params: utils.ensureTypedArg( options.maxAge.randomise, types.BOOLEAN, !!options.maxAge.spread ) ||\n    //     utils.ensureTypedArg( options.wiggle.randomise, types.BOOLEAN, !!options.wiggle.spread ),\n    position: utils.ensureTypedArg(options.position.randomise, types.BOOLEAN, false) || utils.ensureTypedArg(options.radius.randomise, types.BOOLEAN, false),\n    velocity: utils.ensureTypedArg(options.velocity.randomise, types.BOOLEAN, false),\n    acceleration: utils.ensureTypedArg(options.acceleration.randomise, types.BOOLEAN, false) || utils.ensureTypedArg(options.drag.randomise, types.BOOLEAN, false),\n    rotation: utils.ensureTypedArg(options.rotation.randomise, types.BOOLEAN, false),\n    rotationCenter: utils.ensureTypedArg(options.rotation.randomise, types.BOOLEAN, false),\n    size: utils.ensureTypedArg(options.size.randomise, types.BOOLEAN, false),\n    color: utils.ensureTypedArg(options.color.randomise, types.BOOLEAN, false),\n    opacity: utils.ensureTypedArg(options.opacity.randomise, types.BOOLEAN, false),\n    angle: utils.ensureTypedArg(options.angle.randomise, types.BOOLEAN, false)\n  };\n  this.updateFlags = {};\n  this.updateCounts = {}; // A map to indicate which emitter parameters should update\n  // which attribute.\n\n  this.updateMap = {\n    maxAge: 'params',\n    position: 'position',\n    velocity: 'velocity',\n    acceleration: 'acceleration',\n    drag: 'acceleration',\n    wiggle: 'params',\n    rotation: 'rotation',\n    size: 'size',\n    color: 'color',\n    opacity: 'opacity',\n    angle: 'angle'\n  };\n\n  for (var i in this.updateMap) {\n    if (this.updateMap.hasOwnProperty(i)) {\n      this.updateCounts[this.updateMap[i]] = 0.0;\n      this.updateFlags[this.updateMap[i]] = false;\n\n      this._createGetterSetters(this[i], i);\n    }\n  }\n\n  this.bufferUpdateRanges = {};\n  this.attributeKeys = null;\n  this.attributeCount = 0; // Ensure that the value-over-lifetime property objects above\n  // have value and spread properties that are of the same length.\n  //\n  // Also, for now, make sure they have a length of 3 (min/max arguments here).\n\n  utils.ensureValueOverLifetimeCompliance(this.color, lifetimeLength, lifetimeLength);\n  utils.ensureValueOverLifetimeCompliance(this.opacity, lifetimeLength, lifetimeLength);\n  utils.ensureValueOverLifetimeCompliance(this.size, lifetimeLength, lifetimeLength);\n  utils.ensureValueOverLifetimeCompliance(this.angle, lifetimeLength, lifetimeLength);\n};\n\nSPE.Emitter.constructor = SPE.Emitter;\n\nSPE.Emitter.prototype._createGetterSetters = function (propObj, propName) {\n  'use strict';\n\n  var self = this;\n\n  for (var i in propObj) {\n    if (propObj.hasOwnProperty(i)) {\n      var name = i.replace('_', '');\n      Object.defineProperty(propObj, name, {\n        get: function (prop) {\n          return function () {\n            return this[prop];\n          };\n        }(i),\n        set: function (prop) {\n          return function (value) {\n            var mapName = self.updateMap[propName],\n                prevValue = this[prop],\n                length = SPE.valueOverLifetimeLength;\n\n            if (prop === '_rotationCenter') {\n              self.updateFlags.rotationCenter = true;\n              self.updateCounts.rotationCenter = 0.0;\n            } else if (prop === '_randomise') {\n              self.resetFlags[mapName] = value;\n            } else {\n              self.updateFlags[mapName] = true;\n              self.updateCounts[mapName] = 0.0;\n            }\n\n            self.group._updateDefines();\n\n            this[prop] = value; // If the previous value was an array, then make\n            // sure the provided value is interpolated correctly.\n\n            if (Array.isArray(prevValue)) {\n              SPE.utils.ensureValueOverLifetimeCompliance(self[propName], length, length);\n            }\n          };\n        }(i)\n      });\n    }\n  }\n};\n\nSPE.Emitter.prototype._setBufferUpdateRanges = function (keys) {\n  'use strict';\n\n  this.attributeKeys = keys;\n  this.attributeCount = keys.length;\n\n  for (var i = this.attributeCount - 1; i >= 0; --i) {\n    this.bufferUpdateRanges[keys[i]] = {\n      min: Number.POSITIVE_INFINITY,\n      max: Number.NEGATIVE_INFINITY\n    };\n  }\n};\n\nSPE.Emitter.prototype._calculatePPSValue = function (groupMaxAge) {\n  'use strict';\n\n  var particleCount = this.particleCount; // Calculate the `particlesPerSecond` value for this emitter. It's used\n  // when determining which particles should die and which should live to\n  // see another day. Or be born, for that matter. The \"God\" property.\n\n  if (this.duration) {\n    this.particlesPerSecond = particleCount / (groupMaxAge < this.duration ? groupMaxAge : this.duration);\n  } else {\n    this.particlesPerSecond = particleCount / groupMaxAge;\n  }\n};\n\nSPE.Emitter.prototype._setAttributeOffset = function (startIndex) {\n  this.attributeOffset = startIndex;\n  this.activationIndex = startIndex;\n  this.activationEnd = startIndex + this.particleCount;\n};\n\nSPE.Emitter.prototype._assignValue = function (prop, index) {\n  'use strict';\n\n  switch (prop) {\n    case 'position':\n      this._assignPositionValue(index);\n\n      break;\n\n    case 'velocity':\n    case 'acceleration':\n      this._assignForceValue(index, prop);\n\n      break;\n\n    case 'size':\n    case 'opacity':\n      this._assignAbsLifetimeValue(index, prop);\n\n      break;\n\n    case 'angle':\n      this._assignAngleValue(index);\n\n      break;\n\n    case 'params':\n      this._assignParamsValue(index);\n\n      break;\n\n    case 'rotation':\n      this._assignRotationValue(index);\n\n      break;\n\n    case 'color':\n      this._assignColorValue(index);\n\n      break;\n  }\n};\n\nSPE.Emitter.prototype._assignPositionValue = function (index) {\n  'use strict';\n\n  var distributions = SPE.distributions,\n      utils = SPE.utils,\n      prop = this.position,\n      attr = this.attributes.position,\n      value = prop._value,\n      spread = prop._spread,\n      distribution = prop._distribution;\n\n  switch (distribution) {\n    case distributions.BOX:\n      utils.randomVector3(attr, index, value, spread, prop._spreadClamp);\n      break;\n\n    case distributions.SPHERE:\n      utils.randomVector3OnSphere(attr, index, value, prop._radius, prop._spread.x, prop._radiusScale, prop._spreadClamp.x, prop._distributionClamp || this.particleCount);\n      break;\n\n    case distributions.DISC:\n      utils.randomVector3OnDisc(attr, index, value, prop._radius, prop._spread.x, prop._radiusScale, prop._spreadClamp.x);\n      break;\n  }\n};\n\nSPE.Emitter.prototype._assignForceValue = function (index, attrName) {\n  'use strict';\n\n  var distributions = SPE.distributions,\n      utils = SPE.utils,\n      prop = this[attrName],\n      value = prop._value,\n      spread = prop._spread,\n      distribution = prop._distribution,\n      pos,\n      positionX,\n      positionY,\n      positionZ,\n      i;\n\n  switch (distribution) {\n    case distributions.BOX:\n      utils.randomVector3(this.attributes[attrName], index, value, spread);\n      break;\n\n    case distributions.SPHERE:\n      pos = this.attributes.position.typedArray.array;\n      i = index * 3; // Ensure position values aren't zero, otherwise no force will be\n      // applied.\n      // positionX = utils.zeroToEpsilon( pos[ i ], true );\n      // positionY = utils.zeroToEpsilon( pos[ i + 1 ], true );\n      // positionZ = utils.zeroToEpsilon( pos[ i + 2 ], true );\n\n      positionX = pos[i];\n      positionY = pos[i + 1];\n      positionZ = pos[i + 2];\n      utils.randomDirectionVector3OnSphere(this.attributes[attrName], index, positionX, positionY, positionZ, this.position._value, prop._value.x, prop._spread.x);\n      break;\n\n    case distributions.DISC:\n      pos = this.attributes.position.typedArray.array;\n      i = index * 3; // Ensure position values aren't zero, otherwise no force will be\n      // applied.\n      // positionX = utils.zeroToEpsilon( pos[ i ], true );\n      // positionY = utils.zeroToEpsilon( pos[ i + 1 ], true );\n      // positionZ = utils.zeroToEpsilon( pos[ i + 2 ], true );\n\n      positionX = pos[i];\n      positionY = pos[i + 1];\n      positionZ = pos[i + 2];\n      utils.randomDirectionVector3OnDisc(this.attributes[attrName], index, positionX, positionY, positionZ, this.position._value, prop._value.x, prop._spread.x);\n      break;\n  }\n\n  if (attrName === 'acceleration') {\n    var drag = utils.clamp(utils.randomFloat(this.drag._value, this.drag._spread), 0, 1);\n    this.attributes.acceleration.typedArray.array[index * 4 + 3] = drag;\n  }\n};\n\nSPE.Emitter.prototype._assignAbsLifetimeValue = function (index, propName) {\n  'use strict';\n\n  var array = this.attributes[propName].typedArray,\n      prop = this[propName],\n      utils = SPE.utils,\n      value;\n\n  if (utils.arrayValuesAreEqual(prop._value) && utils.arrayValuesAreEqual(prop._spread)) {\n    value = Math.abs(utils.randomFloat(prop._value[0], prop._spread[0]));\n    array.setVec4Components(index, value, value, value, value);\n  } else {\n    array.setVec4Components(index, Math.abs(utils.randomFloat(prop._value[0], prop._spread[0])), Math.abs(utils.randomFloat(prop._value[1], prop._spread[1])), Math.abs(utils.randomFloat(prop._value[2], prop._spread[2])), Math.abs(utils.randomFloat(prop._value[3], prop._spread[3])));\n  }\n};\n\nSPE.Emitter.prototype._assignAngleValue = function (index) {\n  'use strict';\n\n  var array = this.attributes.angle.typedArray,\n      prop = this.angle,\n      utils = SPE.utils,\n      value;\n\n  if (utils.arrayValuesAreEqual(prop._value) && utils.arrayValuesAreEqual(prop._spread)) {\n    value = utils.randomFloat(prop._value[0], prop._spread[0]);\n    array.setVec4Components(index, value, value, value, value);\n  } else {\n    array.setVec4Components(index, utils.randomFloat(prop._value[0], prop._spread[0]), utils.randomFloat(prop._value[1], prop._spread[1]), utils.randomFloat(prop._value[2], prop._spread[2]), utils.randomFloat(prop._value[3], prop._spread[3]));\n  }\n};\n\nSPE.Emitter.prototype._assignParamsValue = function (index) {\n  'use strict';\n\n  this.attributes.params.typedArray.setVec4Components(index, this.isStatic ? 1 : 0, 0.0, Math.abs(SPE.utils.randomFloat(this.maxAge._value, this.maxAge._spread)), SPE.utils.randomFloat(this.wiggle._value, this.wiggle._spread));\n};\n\nSPE.Emitter.prototype._assignRotationValue = function (index) {\n  'use strict';\n\n  this.attributes.rotation.typedArray.setVec3Components(index, SPE.utils.getPackedRotationAxis(this.rotation._axis, this.rotation._axisSpread), SPE.utils.randomFloat(this.rotation._angle, this.rotation._angleSpread), this.rotation._static ? 0 : 1);\n  this.attributes.rotationCenter.typedArray.setVec3(index, this.rotation._center);\n};\n\nSPE.Emitter.prototype._assignColorValue = function (index) {\n  'use strict';\n\n  SPE.utils.randomColorAsHex(this.attributes.color, index, this.color._value, this.color._spread);\n};\n\nSPE.Emitter.prototype._resetParticle = function (index) {\n  'use strict';\n\n  var resetFlags = this.resetFlags,\n      updateFlags = this.updateFlags,\n      updateCounts = this.updateCounts,\n      keys = this.attributeKeys,\n      key,\n      updateFlag;\n\n  for (var i = this.attributeCount - 1; i >= 0; --i) {\n    key = keys[i];\n    updateFlag = updateFlags[key];\n\n    if (resetFlags[key] === true || updateFlag === true) {\n      this._assignValue(key, index);\n\n      this._updateAttributeUpdateRange(key, index);\n\n      if (updateFlag === true && updateCounts[key] === this.particleCount) {\n        updateFlags[key] = false;\n        updateCounts[key] = 0.0;\n      } else if (updateFlag == true) {\n        ++updateCounts[key];\n      }\n    }\n  }\n};\n\nSPE.Emitter.prototype._updateAttributeUpdateRange = function (attr, i) {\n  'use strict';\n\n  var ranges = this.bufferUpdateRanges[attr];\n  ranges.min = Math.min(i, ranges.min);\n  ranges.max = Math.max(i, ranges.max);\n};\n\nSPE.Emitter.prototype._resetBufferRanges = function () {\n  'use strict';\n\n  var ranges = this.bufferUpdateRanges,\n      keys = this.bufferUpdateKeys,\n      i = this.bufferUpdateCount - 1,\n      key;\n\n  for (i; i >= 0; --i) {\n    key = keys[i];\n    ranges[key].min = Number.POSITIVE_INFINITY;\n    ranges[key].max = Number.NEGATIVE_INFINITY;\n  }\n};\n\nSPE.Emitter.prototype._onRemove = function () {\n  'use strict'; // Reset any properties of the emitter that were set by\n  // a group when it was added.\n\n  this.particlesPerSecond = 0;\n  this.attributeOffset = 0;\n  this.activationIndex = 0;\n  this.activeParticleCount = 0;\n  this.group = null;\n  this.attributes = null;\n  this.paramsArray = null;\n  this.age = 0.0;\n};\n\nSPE.Emitter.prototype._decrementParticleCount = function () {\n  'use strict';\n\n  --this.activeParticleCount; // TODO:\n  //  - Trigger event if count === 0.\n};\n\nSPE.Emitter.prototype._incrementParticleCount = function () {\n  'use strict';\n\n  ++this.activeParticleCount; // TODO:\n  //  - Trigger event if count === this.particleCount.\n};\n\nSPE.Emitter.prototype._checkParticleAges = function (start, end, params, dt) {\n  'use strict';\n\n  for (var i = end - 1, index, maxAge, age, alive; i >= start; --i) {\n    index = i * 4;\n    alive = params[index];\n\n    if (alive === 0.0) {\n      continue;\n    } // Increment age\n\n\n    age = params[index + 1];\n    maxAge = params[index + 2];\n\n    if (this.direction === 1) {\n      age += dt;\n\n      if (age >= maxAge) {\n        age = 0.0;\n        alive = 0.0;\n\n        this._decrementParticleCount();\n      }\n    } else {\n      age -= dt;\n\n      if (age <= 0.0) {\n        age = maxAge;\n        alive = 0.0;\n\n        this._decrementParticleCount();\n      }\n    }\n\n    params[index] = alive;\n    params[index + 1] = age;\n\n    this._updateAttributeUpdateRange('params', i);\n  }\n};\n\nSPE.Emitter.prototype._activateParticles = function (activationStart, activationEnd, params, dtPerParticle) {\n  'use strict';\n\n  var direction = this.direction;\n\n  for (var i = activationStart, index, dtValue; i < activationEnd; ++i) {\n    index = i * 4; // Don't re-activate particles that aren't dead yet.\n    // if ( params[ index ] !== 0.0 && ( this.particleCount !== 1 || this.activeMultiplier !== 1 ) ) {\n    //     continue;\n    // }\n\n    if (params[index] != 0.0 && this.particleCount !== 1) {\n      continue;\n    } // Increment the active particle count.\n\n\n    this._incrementParticleCount(); // Mark the particle as alive.\n\n\n    params[index] = 1.0; // Reset the particle\n\n    this._resetParticle(i); // Move each particle being activated to\n    // it's actual position in time.\n    //\n    // This stops particles being 'clumped' together\n    // when frame rates are on the lower side of 60fps\n    // or not constant (a very real possibility!)\n\n\n    dtValue = dtPerParticle * (i - activationStart);\n    params[index + 1] = direction === -1 ? params[index + 2] - dtValue : dtValue;\n\n    this._updateAttributeUpdateRange('params', i);\n  }\n};\n/**\n * Simulates one frame's worth of particles, updating particles\n * that are already alive, and marking ones that are currently dead\n * but should be alive as alive.\n *\n * If the emitter is marked as static, then this function will do nothing.\n *\n * @param  {Number} dt The number of seconds to simulate (deltaTime)\n */\n\n\nSPE.Emitter.prototype.tick = function (dt) {\n  'use strict';\n\n  if (this.isStatic) {\n    return;\n  }\n\n  if (this.paramsArray === null) {\n    this.paramsArray = this.attributes.params.typedArray.array;\n  }\n\n  var start = this.attributeOffset,\n      end = start + this.particleCount,\n      params = this.paramsArray,\n      // vec3( alive, age, maxAge, wiggle )\n  ppsDt = this.particlesPerSecond * this.activeMultiplier * dt,\n      activationIndex = this.activationIndex; // Reset the buffer update indices.\n\n  this._resetBufferRanges(); // Increment age for those particles that are alive,\n  // and kill off any particles whose age is over the limit.\n\n\n  this._checkParticleAges(start, end, params, dt); // If the emitter is dead, reset the age of the emitter to zero,\n  // ready to go again if required\n\n\n  if (this.alive === false) {\n    this.age = 0.0;\n    return;\n  } // If the emitter has a specified lifetime and we've exceeded it,\n  // mark the emitter as dead.\n\n\n  if (this.duration !== null && this.age > this.duration) {\n    this.alive = false;\n    this.age = 0.0;\n    return;\n  }\n\n  var activationStart = this.particleCount === 1 ? activationIndex : activationIndex | 0,\n      activationEnd = Math.min(activationStart + ppsDt, this.activationEnd),\n      activationCount = activationEnd - this.activationIndex | 0,\n      dtPerParticle = activationCount > 0 ? dt / activationCount : 0;\n\n  this._activateParticles(activationStart, activationEnd, params, dtPerParticle); // Move the activation window forward, soldier.\n\n\n  this.activationIndex += ppsDt;\n\n  if (this.activationIndex > end) {\n    this.activationIndex = start;\n  } // Increment the age of the emitter.\n\n\n  this.age += dt;\n};\n/**\n * Resets all the emitter's particles to their start positions\n * and marks the particles as dead if the `force` argument is\n * true.\n *\n * @param  {Boolean} [force=undefined] If true, all particles will be marked as dead instantly.\n * @return {Emitter}       This emitter instance.\n */\n\n\nSPE.Emitter.prototype.reset = function (force) {\n  'use strict';\n\n  this.age = 0.0;\n  this.alive = false;\n\n  if (force === true) {\n    var start = this.attributeOffset,\n        end = start + this.particleCount,\n        array = this.paramsArray,\n        attr = this.attributes.params.bufferAttribute;\n\n    for (var i = end - 1, index; i >= start; --i) {\n      index = i * 4;\n      array[index] = 0.0;\n      array[index + 1] = 0.0;\n    }\n\n    attr.updateRange.offset = 0;\n    attr.updateRange.count = -1;\n    attr.needsUpdate = true;\n  }\n\n  return this;\n};\n/**\n * Enables the emitter. If not already enabled, the emitter\n * will start emitting particles.\n *\n * @return {Emitter} This emitter instance.\n */\n\n\nSPE.Emitter.prototype.enable = function () {\n  'use strict';\n\n  this.alive = true;\n  return this;\n};\n/**\n * Disables th emitter, but does not instantly remove it's\n * particles fromt the scene. When called, the emitter will be\n * 'switched off' and just stop emitting. Any particle's alive will\n * be allowed to finish their lifecycle.\n *\n * @return {Emitter} This emitter instance.\n */\n\n\nSPE.Emitter.prototype.disable = function () {\n  'use strict';\n\n  this.alive = false;\n  return this;\n};\n/**\n * Remove this emitter from it's parent group (if it has been added to one).\n * Delgates to SPE.group.prototype.removeEmitter().\n *\n * When called, all particle's belonging to this emitter will be instantly\n * removed from the scene.\n *\n * @return {Emitter} This emitter instance.\n *\n * @see SPE.Group.prototype.removeEmitter\n */\n\n\nSPE.Emitter.prototype.remove = function () {\n  'use strict';\n\n  if (this.group !== null) {\n    this.group.removeEmitter(this);\n  } else {\n    console.error('Emitter does not belong to a group, cannot remove.');\n  }\n\n  return this;\n};","map":{"version":3,"sources":["/Users/kittathat/Documents/window/SE/Year 4/Year 4 Project/year4/node_modules/aframe-particle-system-component/lib/SPE.js"],"names":["SPE","distributions","BOX","SPHERE","DISC","valueOverLifetimeLength","define","amd","exports","module","TypedArrayHelper","TypedArrayConstructor","size","componentSize","indexOffset","Float32Array","array","constructor","prototype","setSize","noComponentMultiply","currentArraySize","length","shrink","grow","console","info","subarray","existingArray","newArray","set","splice","start","end","data","i","push","setFromArray","index","sourceArraySize","newSize","setVec2","vec2","setVec2Components","x","y","setVec3","vec3","setVec3Components","z","setVec4","vec4","setVec4Components","w","setMat3","mat3","elements","setMat4","mat4","setColor","color","r","g","b","setNumber","numericValue","getValueAtIndex","getComponentValueAtIndex","ShaderAttribute","type","dynamicBuffer","arrayType","typeMap","typeSizeMap","hasOwnProperty","typedArray","bufferAttribute","updateMin","updateMax","f","v2","v3","v4","c","m3","m4","setUpdateRange","min","max","Math","flagUpdate","attr","range","updateRange","offset","count","needsUpdate","resetUpdateRange","resetDynamic","dynamic","forceUpdateAll","_ensureTypedArray","_createBufferAttribute","THREE","BufferAttribute","getLength","shaderChunks","defines","join","uniforms","attributes","varyings","branchAvoidanceFunctions","unpackColor","unpackRotationAxis","floatOverLifetime","colorOverLifetime","paramFetchingFunctions","forceFetchingFunctions","rotationFunctions","rotateTexture","shaders","vertex","ShaderChunk","common","logdepthbuf_pars_vertex","fog_pars_vertex","logdepthbuf_vertex","fog_vertex","fragment","fog_pars_fragment","logdepthbuf_pars_fragment","logdepthbuf_fragment","fog_fragment","utils","types","BOOLEAN","STRING","NUMBER","OBJECT","ensureTypedArg","arg","defaultValue","ensureArrayTypedArg","Array","isArray","ensureInstanceOf","instance","undefined","ensureArrayInstanceOf","ensureValueOverLifetimeCompliance","property","minLength","maxLength","_value","_spread","valueLength","clamp","spreadLength","desiredLength","interpolateArray","srcArray","newLength","sourceLength","clone","factor","before","floor","after","ceil","delta","lerpTypeAgnostic","value","zeroToEpsilon","randomise","epsilon","result","random","out","Vector2","lerp","Vector3","Vector4","Color","warn","roundToNearestMultiple","n","multiple","remainder","abs","arrayValuesAreEqual","randomFloat","base","spread","randomVector3","attribute","spreadClamp","randomColor","randomColorAsHex","workingColor","numItems","colors","spreadVector","copy","getHex","randomVector3OnSphere","radius","radiusSpread","radiusScale","radiusSpreadClamp","distributionClamp","depth","t","sqrt","rand","round","cos","sin","seededRandom","seed","randomVector3OnDisc","randomDirectionVector3OnSphere","v","posX","posY","posZ","emitterPosition","speed","speedSpread","normalize","multiplyScalar","randomDirectionVector3OnDisc","getPackedRotationAxis","vSpread","addOne","axis","axisSpread","add","setRGB","Group","options","texture","uuid","generateUUID","fixedTimeStep","Texture","textureFrames","frames","textureFrameCount","frameCount","textureLoop","loop","hasPerspective","colorize","maxParticleCount","blending","AdditiveBlending","transparent","alphaTest","parseFloat","depthWrite","depthTest","fog","scale","emitters","emitterIDs","_pool","_poolCreationSettings","_createNewWhenPoolEmpty","_attributesNeedRefresh","_attributesNeedDynamicReset","particleCount","textureAnimation","fogColor","fogNear","fogFar","fogDensity","deltaTime","runTime","HAS_PERSPECTIVE","COLORIZE","VALUE_OVER_LIFETIME_LENGTH","SHOULD_ROTATE_TEXTURE","SHOULD_ROTATE_PARTICLES","SHOULD_WIGGLE_PARTICLES","SHOULD_CALCULATE_SPRITE","position","acceleration","velocity","rotation","rotationCenter","params","angle","opacity","attributeKeys","Object","keys","attributeCount","material","ShaderMaterial","vertexShader","fragmentShader","geometry","BufferGeometry","mesh","Points","_updateDefines","emitter","apply","angleSpread","wiggle","_applyAttributesToGeometry","geometryAttributes","geometryAttribute","addAttribute","setDrawRange","addEmitter","Emitter","error","indexOf","group","_calculatePPSValue","maxAge","_setBufferUpdateRanges","_setAttributeOffset","_assignPositionValue","_assignForceValue","_assignAbsLifetimeValue","_assignAngleValue","_assignRotationValue","_assignParamsValue","_assignColorValue","removeEmitter","emitterIndex","attributeOffset","_onRemove","getFromPool","pool","createNew","pop","releaseIntoPool","reset","unshift","getPool","addPool","numEmitters","emitterOptions","_triggerSingleEmitter","pos","self","log","enable","setTimeout","disable","duration","triggerPoolEmitter","_updateUniforms","dt","_resetBufferRanges","attrs","_updateBuffers","emitterRanges","bufferUpdateRanges","key","emitterAttr","tick","dispose","lifetimeLength","drag","onParticleSpawn","_spreadClamp","_distribution","distribution","_randomise","_radius","_radiusScale","_distributionClamp","_axis","_axisSpread","_angle","_angleSpread","_static","static","_center","center","isStatic","activeMultiplier","direction","alive","particlesPerSecond","activationIndex","attributeEnd","age","activeParticleCount","paramsArray","resetFlags","updateFlags","updateCounts","updateMap","_createGetterSetters","propObj","propName","name","replace","defineProperty","get","prop","mapName","prevValue","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","groupMaxAge","startIndex","activationEnd","_assignValue","attrName","positionX","positionY","positionZ","_resetParticle","updateFlag","_updateAttributeUpdateRange","ranges","bufferUpdateKeys","bufferUpdateCount","_decrementParticleCount","_incrementParticleCount","_checkParticleAges","_activateParticles","activationStart","dtPerParticle","dtValue","ppsDt","activationCount","force","remove"],"mappings":"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AA1B;;AAEA,SAAMtQ,CAAN,EAASA,CAAC,IAAI,CAAd,EAAiB,EAAEA,CAAnB,EAAuB;AACnBoU,MAAAA,KAAK,CAAE/D,IAAI,CAAErQ,CAAF,CAAN,CAAL,CAAmBiE,cAAnB;AACH;;AAED,SAAKyK,sBAAL,GAA8B,KAA9B;AACA,SAAKC,2BAAL,GAAmC,IAAnC;AACH;AACJ,CA9DD;AAiEA;AACA;AACA;AACA;AACA;;;AACA9Q,GAAG,CAAC+O,KAAJ,CAAU7N,SAAV,CAAoB4V,OAApB,GAA8B,YAAW;AACrC;;AACA,OAAKhE,QAAL,CAAcgE,OAAd;AACA,OAAKpE,QAAL,CAAcoE,OAAd;AACA,SAAO,IAAP;AACH,CALD;AAOA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA9W,GAAG,CAAC6T,OAAJ,GAAc,UAAU7E,OAAV,EAAoB;AAC9B;;AAEA,MAAI1G,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","sourcesContent":["/* shader-particle-engine 1.0.5\n *\n * (c) 2015 Luke Moody (http://www.github.com/squarefeet)\n *     Originally based on Lee Stemkoski's original work (https://github.com/stemkoski/stemkoski.github.com/blob/master/Three.js/js/ParticleEngine.js).\n *\n * shader-particle-engine may be freely distributed under the MIT license (See LICENSE at root of this repository.)\n */\n/**\n * @typedef {Number} distribution\n * @property {Number} SPE.distributions.BOX Values will be distributed within a box.\n * @property {Number} SPE.distributions.SPHERE Values will be distributed within a sphere.\n * @property {Number} SPE.distributions.DISC Values will be distributed within a 2D disc.\n */\n\n/**\n * Namespace for Shader Particle Engine.\n *\n * All SPE-related code sits under this namespace.\n *\n * @type {Object}\n * @namespace\n */\nvar SPE = {\n\n    /**\n     * A map of supported distribution types used\n     * by SPE.Emitter instances.\n     *\n     * These distribution types can be applied to\n     * an emitter globally, which will affect the\n     * `position`, `velocity`, and `acceleration`\n     * value calculations for an emitter, or they\n     * can be applied on a per-property basis.\n     *\n     * @enum {Number}\n     */\n    distributions: {\n        /**\n         * Values will be distributed within a box.\n         * @type {Number}\n         */\n        BOX: 1,\n\n        /**\n         * Values will be distributed on a sphere.\n         * @type {Number}\n         */\n        SPHERE: 2,\n\n        /**\n         * Values will be distributed on a 2d-disc shape.\n         * @type {Number}\n         */\n        DISC: 3,\n    },\n\n\n    /**\n     * Set this value to however many 'steps' you\n     * want value-over-lifetime properties to have.\n     *\n     * It's adjustable to fix an interpolation problem:\n     *\n     * Assuming you specify an opacity value as [0, 1, 0]\n     *      and the `valueOverLifetimeLength` is 4, then the\n     *      opacity value array will be reinterpolated to\n     *      be [0, 0.66, 0.66, 0].\n     *   This isn't ideal, as particles would never reach\n     *   full opacity.\n     *\n     * NOTE:\n     *     This property affects the length of ALL\n     *       value-over-lifetime properties for ALL\n     *       emitters and ALL groups.\n     *\n     *     Only values >= 3 && <= 4 are allowed.\n     *\n     * @type {Number}\n     */\n    valueOverLifetimeLength: 4\n};\n\n// Module loader support:\nif ( typeof define === 'function' && define.amd ) {\n    define( 'spe', SPE );\n}\nelse if ( typeof exports !== 'undefined' && typeof module !== 'undefined' ) {\n    module.exports = SPE;\n}\n\n/**\n * A helper class for TypedArrays.\n *\n * Allows for easy resizing, assignment of various component-based\n * types (Vector2s, Vector3s, Vector4s, Mat3s, Mat4s),\n * as well as Colors (where components are `r`, `g`, `b`),\n * Numbers, and setting from other TypedArrays.\n *\n * @author Luke Moody\n * @constructor\n * @param {Function} TypedArrayConstructor The constructor to use (Float32Array, Uint8Array, etc.)\n * @param {Number} size                 The size of the array to create\n * @param {Number} componentSize        The number of components per-value (ie. 3 for a vec3, 9 for a Mat3, etc.)\n * @param {Number} indexOffset          The index in the array from which to start assigning values. Default `0` if none provided\n */\nSPE.TypedArrayHelper = function( TypedArrayConstructor, size, componentSize, indexOffset ) {\n    'use strict';\n\n    this.componentSize = componentSize || 1;\n    this.size = ( size || 1 );\n    this.TypedArrayConstructor = TypedArrayConstructor || Float32Array;\n    this.array = new TypedArrayConstructor( size * this.componentSize );\n    this.indexOffset = indexOffset || 0;\n};\n\nSPE.TypedArrayHelper.constructor = SPE.TypedArrayHelper;\n\n/**\n * Sets the size of the internal array.\n *\n * Delegates to `this.shrink` or `this.grow` depending on size\n * argument's relation to the current size of the internal array.\n *\n * Note that if the array is to be shrunk, data will be lost.\n *\n * @param {Number} size The new size of the array.\n */\nSPE.TypedArrayHelper.prototype.setSize = function( size, noComponentMultiply ) {\n    'use strict';\n\n    var currentArraySize = this.array.length;\n\n    if ( !noComponentMultiply ) {\n        size = size * this.componentSize;\n    }\n\n    if ( size < currentArraySize ) {\n        return this.shrink( size );\n    }\n    else if ( size > currentArraySize ) {\n        return this.grow( size );\n    }\n    else {\n        console.info( 'TypedArray is already of size:', size + '.', 'Will not resize.' );\n    }\n};\n\n/**\n * Shrinks the internal array.\n *\n * @param  {Number} size The new size of the typed array. Must be smaller than `this.array.length`.\n * @return {SPE.TypedArrayHelper}      Instance of this class.\n */\nSPE.TypedArrayHelper.prototype.shrink = function( size ) {\n    'use strict';\n\n    this.array = this.array.subarray( 0, size );\n    this.size = size;\n    return this;\n};\n\n/**\n * Grows the internal array.\n * @param  {Number} size The new size of the typed array. Must be larger than `this.array.length`.\n * @return {SPE.TypedArrayHelper}      Instance of this class.\n */\nSPE.TypedArrayHelper.prototype.grow = function( size ) {\n    'use strict';\n\n    var existingArray = this.array,\n        newArray = new this.TypedArrayConstructor( size );\n\n    newArray.set( existingArray );\n    this.array = newArray;\n    this.size = size;\n\n    return this;\n};\n\n\n/**\n * Perform a splice operation on this array's buffer.\n * @param  {Number} start The start index of the splice. Will be multiplied by the number of components for this attribute.\n * @param  {Number} end The end index of the splice. Will be multiplied by the number of components for this attribute.\n * @returns {Object} The SPE.TypedArrayHelper instance.\n */\nSPE.TypedArrayHelper.prototype.splice = function( start, end ) {\n    'use strict';\n    start *= this.componentSize;\n    end *= this.componentSize;\n\n    var data = [],\n        array = this.array,\n        size = array.length;\n\n    for ( var i = 0; i < size; ++i ) {\n        if ( i < start || i >= end ) {\n            data.push( array[ i ] );\n        }\n        // array[ i ] = 0;\n    }\n\n    this.setFromArray( 0, data );\n\n    return this;\n};\n\n\n/**\n * Copies from the given TypedArray into this one, using the index argument\n * as the start position. Alias for `TypedArray.set`. Will automatically resize\n * if the given source array is of a larger size than the internal array.\n *\n * @param {Number} index      The start position from which to copy into this array.\n * @param {TypedArray} array The array from which to copy; the source array.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\nSPE.TypedArrayHelper.prototype.setFromArray = function( index, array ) {\n    'use strict';\n\n    var sourceArraySize = array.length,\n        newSize = index + sourceArraySize;\n\n    if ( newSize > this.array.length ) {\n        this.grow( newSize );\n    }\n    else if ( newSize < this.array.length ) {\n        this.shrink( newSize );\n    }\n\n    this.array.set( array, this.indexOffset + index );\n\n    return this;\n};\n\n/**\n * Set a Vector2 value at `index`.\n *\n * @param {Number} index The index at which to set the vec2 values from.\n * @param {Vector2} vec2  Any object that has `x` and `y` properties.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\nSPE.TypedArrayHelper.prototype.setVec2 = function( index, vec2 ) {\n    'use strict';\n\n    return this.setVec2Components( index, vec2.x, vec2.y );\n};\n\n/**\n * Set a Vector2 value using raw components.\n *\n * @param {Number} index The index at which to set the vec2 values from.\n * @param {Number} x     The Vec2's `x` component.\n * @param {Number} y     The Vec2's `y` component.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\nSPE.TypedArrayHelper.prototype.setVec2Components = function( index, x, y ) {\n    'use strict';\n\n    var array = this.array,\n        i = this.indexOffset + ( index * this.componentSize );\n\n    array[ i ] = x;\n    array[ i + 1 ] = y;\n    return this;\n};\n\n/**\n * Set a Vector3 value at `index`.\n *\n * @param {Number} index The index at which to set the vec3 values from.\n * @param {Vector3} vec2  Any object that has `x`, `y`, and `z` properties.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\nSPE.TypedArrayHelper.prototype.setVec3 = function( index, vec3 ) {\n    'use strict';\n\n    return this.setVec3Components( index, vec3.x, vec3.y, vec3.z );\n};\n\n/**\n * Set a Vector3 value using raw components.\n *\n * @param {Number} index The index at which to set the vec3 values from.\n * @param {Number} x     The Vec3's `x` component.\n * @param {Number} y     The Vec3's `y` component.\n * @param {Number} z     The Vec3's `z` component.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\nSPE.TypedArrayHelper.prototype.setVec3Components = function( index, x, y, z ) {\n    'use strict';\n\n    var array = this.array,\n        i = this.indexOffset + ( index * this.componentSize );\n\n    array[ i ] = x;\n    array[ i + 1 ] = y;\n    array[ i + 2 ] = z;\n    return this;\n};\n\n/**\n * Set a Vector4 value at `index`.\n *\n * @param {Number} index The index at which to set the vec4 values from.\n * @param {Vector4} vec2  Any object that has `x`, `y`, `z`, and `w` properties.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\nSPE.TypedArrayHelper.prototype.setVec4 = function( index, vec4 ) {\n    'use strict';\n\n    return this.setVec4Components( index, vec4.x, vec4.y, vec4.z, vec4.w );\n};\n\n/**\n * Set a Vector4 value using raw components.\n *\n * @param {Number} index The index at which to set the vec4 values from.\n * @param {Number} x     The Vec4's `x` component.\n * @param {Number} y     The Vec4's `y` component.\n * @param {Number} z     The Vec4's `z` component.\n * @param {Number} w     The Vec4's `w` component.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\nSPE.TypedArrayHelper.prototype.setVec4Components = function( index, x, y, z, w ) {\n    'use strict';\n\n    var array = this.array,\n        i = this.indexOffset + ( index * this.componentSize );\n\n    array[ i ] = x;\n    array[ i + 1 ] = y;\n    array[ i + 2 ] = z;\n    array[ i + 3 ] = w;\n    return this;\n};\n\n/**\n * Set a Matrix3 value at `index`.\n *\n * @param {Number} index The index at which to set the matrix values from.\n * @param {Matrix3} mat3 The 3x3 matrix to set from. Must have a TypedArray property named `elements` to copy from.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\nSPE.TypedArrayHelper.prototype.setMat3 = function( index, mat3 ) {\n    'use strict';\n\n    return this.setFromArray( this.indexOffset + ( index * this.componentSize ), mat3.elements );\n};\n\n/**\n * Set a Matrix4 value at `index`.\n *\n * @param {Number} index The index at which to set the matrix values from.\n * @param {Matrix4} mat3 The 4x4 matrix to set from. Must have a TypedArray property named `elements` to copy from.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\nSPE.TypedArrayHelper.prototype.setMat4 = function( index, mat4 ) {\n    'use strict';\n\n    return this.setFromArray( this.indexOffset + ( index * this.componentSize ), mat4.elements );\n};\n\n/**\n * Set a Color value at `index`.\n *\n * @param {Number} index The index at which to set the vec3 values from.\n * @param {Color} color  Any object that has `r`, `g`, and `b` properties.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\nSPE.TypedArrayHelper.prototype.setColor = function( index, color ) {\n    'use strict';\n\n    return this.setVec3Components( index, color.r, color.g, color.b );\n};\n\n/**\n * Set a Number value at `index`.\n *\n * @param {Number} index The index at which to set the vec3 values from.\n * @param {Number} numericValue  The number to assign to this index in the array.\n * @return {SPE.TypedArrayHelper} Instance of this class.\n */\nSPE.TypedArrayHelper.prototype.setNumber = function( index, numericValue ) {\n    'use strict';\n\n    this.array[ this.indexOffset + ( index * this.componentSize ) ] = numericValue;\n    return this;\n};\n\n/**\n * Returns the value of the array at the given index, taking into account\n * the `indexOffset` property of this class.\n *\n * Note that this function ignores the component size and will just return a\n * single value.\n *\n * @param  {Number} index The index in the array to fetch.\n * @return {Number}       The value at the given index.\n */\nSPE.TypedArrayHelper.prototype.getValueAtIndex = function( index ) {\n    'use strict';\n\n    return this.array[ this.indexOffset + index ];\n};\n\n/**\n * Returns the component value of the array at the given index, taking into account\n * the `indexOffset` property of this class.\n *\n * If the componentSize is set to 3, then it will return a new TypedArray\n * of length 3.\n *\n * @param  {Number} index The index in the array to fetch.\n * @return {TypedArray}       The component value at the given index.\n */\nSPE.TypedArrayHelper.prototype.getComponentValueAtIndex = function( index ) {\n    'use strict';\n\n    return this.array.subarray( this.indexOffset + ( index * this.componentSize ) );\n};\n\n/**\n * A helper to handle creating and updating a THREE.BufferAttribute instance.\n *\n * @author  Luke Moody\n * @constructor\n * @param {String} type          The buffer attribute type. See SPE.ShaderAttribute.typeSizeMap for valid values.\n * @param {Boolean=} dynamicBuffer Whether this buffer attribute should be marked as dynamic or not.\n * @param {Function=} arrayType     A reference to a TypedArray constructor. Defaults to Float32Array if none provided.\n */\nSPE.ShaderAttribute = function( type, dynamicBuffer, arrayType ) {\n    'use strict';\n\n    var typeMap = SPE.ShaderAttribute.typeSizeMap;\n\n    this.type = typeof type === 'string' && typeMap.hasOwnProperty( type ) ? type : 'f';\n    this.componentSize = typeMap[ this.type ];\n    this.arrayType = arrayType || Float32Array;\n    this.typedArray = null;\n    this.bufferAttribute = null;\n    this.dynamicBuffer = !!dynamicBuffer;\n\n    this.updateMin = 0;\n    this.updateMax = 0;\n};\n\nSPE.ShaderAttribute.constructor = SPE.ShaderAttribute;\n\n/**\n * A map of uniform types to their component size.\n * @enum {Number}\n */\nSPE.ShaderAttribute.typeSizeMap = {\n    /**\n     * Float\n     * @type {Number}\n     */\n    f: 1,\n\n    /**\n     * Vec2\n     * @type {Number}\n     */\n    v2: 2,\n\n    /**\n     * Vec3\n     * @type {Number}\n     */\n    v3: 3,\n\n    /**\n     * Vec4\n     * @type {Number}\n     */\n    v4: 4,\n\n    /**\n     * Color\n     * @type {Number}\n     */\n    c: 3,\n\n    /**\n     * Mat3\n     * @type {Number}\n     */\n    m3: 9,\n\n    /**\n     * Mat4\n     * @type {Number}\n     */\n    m4: 16\n};\n\n/**\n * Calculate the minimum and maximum update range for this buffer attribute using\n * component size independant min and max values.\n *\n * @param {Number} min The start of the range to mark as needing an update.\n * @param {Number} max The end of the range to mark as needing an update.\n */\nSPE.ShaderAttribute.prototype.setUpdateRange = function( min, max ) {\n    'use strict';\n\n    this.updateMin = Math.min( min * this.componentSize, this.updateMin * this.componentSize );\n    this.updateMax = Math.max( max * this.componentSize, this.updateMax * this.componentSize );\n};\n\n/**\n * Calculate the number of indices that this attribute should mark as needing\n * updating. Also marks the attribute as needing an update.\n */\nSPE.ShaderAttribute.prototype.flagUpdate = function() {\n    'use strict';\n\n    var attr = this.bufferAttribute,\n        range = attr.updateRange;\n\n    range.offset = this.updateMin;\n    range.count = Math.min( ( this.updateMax - this.updateMin ) + this.componentSize, this.typedArray.array.length );\n    // console.log( range.offset, range.count, this.typedArray.array.length );\n    // console.log( 'flagUpdate:', range.offset, range.count );\n    attr.needsUpdate = true;\n};\n\n\n\n/**\n * Reset the index update counts for this attribute\n */\nSPE.ShaderAttribute.prototype.resetUpdateRange = function() {\n    'use strict';\n\n    this.updateMin = 0;\n    this.updateMax = 0;\n};\n\nSPE.ShaderAttribute.prototype.resetDynamic = function() {\n    'use strict';\n    this.bufferAttribute.dynamic = this.dynamicBuffer;\n};\n\n/**\n * Perform a splice operation on this attribute's buffer.\n * @param  {Number} start The start index of the splice. Will be multiplied by the number of components for this attribute.\n * @param  {Number} end The end index of the splice. Will be multiplied by the number of components for this attribute.\n */\nSPE.ShaderAttribute.prototype.splice = function( start, end ) {\n    'use strict';\n\n    this.typedArray.splice( start, end );\n\n    // Reset the reference to the attribute's typed array\n    // since it has probably changed.\n    this.forceUpdateAll();\n};\n\nSPE.ShaderAttribute.prototype.forceUpdateAll = function() {\n    'use strict';\n\n    this.bufferAttribute.array = this.typedArray.array;\n    this.bufferAttribute.updateRange.offset = 0;\n    this.bufferAttribute.updateRange.count = -1;\n    this.bufferAttribute.dynamic = false;\n    this.bufferAttribute.needsUpdate = true;\n};\n\n/**\n * Make sure this attribute has a typed array associated with it.\n *\n * If it does, then it will ensure the typed array is of the correct size.\n *\n * If not, a new SPE.TypedArrayHelper instance will be created.\n *\n * @param  {Number} size The size of the typed array to create or update to.\n */\nSPE.ShaderAttribute.prototype._ensureTypedArray = function( size ) {\n    'use strict';\n\n    // Condition that's most likely to be true at the top: no change.\n    if ( this.typedArray !== null && this.typedArray.size === size * this.componentSize ) {\n        return;\n    }\n\n    // Resize the array if we need to, telling the TypedArrayHelper to\n    // ignore it's component size when evaluating size.\n    else if ( this.typedArray !== null && this.typedArray.size !== size ) {\n        this.typedArray.setSize( size );\n    }\n\n    // This condition should only occur once in an attribute's lifecycle.\n    else if ( this.typedArray === null ) {\n        this.typedArray = new SPE.TypedArrayHelper( this.arrayType, size, this.componentSize );\n    }\n};\n\n\n/**\n * Creates a THREE.BufferAttribute instance if one doesn't exist already.\n *\n * Ensures a typed array is present by calling _ensureTypedArray() first.\n *\n * If a buffer attribute exists already, then it will be marked as needing an update.\n *\n * @param  {Number} size The size of the typed array to create if one doesn't exist, or resize existing array to.\n */\nSPE.ShaderAttribute.prototype._createBufferAttribute = function( size ) {\n    'use strict';\n\n    // Make sure the typedArray is present and correct.\n    this._ensureTypedArray( size );\n\n    // Don't create it if it already exists, but do\n    // flag that it needs updating on the next render\n    // cycle.\n    if ( this.bufferAttribute !== null ) {\n        this.bufferAttribute.array = this.typedArray.array;\n        this.bufferAttribute.needsUpdate = true;\n        return;\n    }\n\n    this.bufferAttribute = new THREE.BufferAttribute( this.typedArray.array, this.componentSize );\n    this.bufferAttribute.dynamic = this.dynamicBuffer;\n};\n\n/**\n * Returns the length of the typed array associated with this attribute.\n * @return {Number} The length of the typed array. Will be 0 if no typed array has been created yet.\n */\nSPE.ShaderAttribute.prototype.getLength = function() {\n    'use strict';\n\n    if ( this.typedArray === null ) {\n        return 0;\n    }\n\n    return this.typedArray.array.length;\n};\n\nSPE.shaderChunks = {\n    // Register color-packing define statements.\n    defines: [\n        '#define PACKED_COLOR_SIZE 256.0',\n        '#define PACKED_COLOR_DIVISOR 255.0'\n    ].join( '\\n' ),\n\n    // All uniforms used by vertex / fragment shaders\n    uniforms: [\n        'uniform float deltaTime;',\n        'uniform float runTime;',\n        'uniform sampler2D texture;',\n        'uniform vec4 textureAnimation;',\n        'uniform float scale;',\n    ].join( '\\n' ),\n\n    // All attributes used by the vertex shader.\n    //\n    // Note that some attributes are squashed into other ones:\n    //\n    // * Drag is acceleration.w\n    attributes: [\n        'attribute vec4 acceleration;',\n        'attribute vec3 velocity;',\n        'attribute vec4 rotation;',\n        'attribute vec3 rotationCenter;',\n        'attribute vec4 params;',\n        'attribute vec4 size;',\n        'attribute vec4 angle;',\n        'attribute vec4 color;',\n        'attribute vec4 opacity;'\n    ].join( '\\n' ),\n\n    //\n    varyings: [\n        'varying vec4 vColor;',\n        '#ifdef SHOULD_ROTATE_TEXTURE',\n        '    varying float vAngle;',\n        '#endif',\n\n        '#ifdef SHOULD_CALCULATE_SPRITE',\n        '    varying vec4 vSpriteSheet;',\n        '#endif'\n    ].join( '\\n' ),\n\n\n    // Branch-avoiding comparison fns\n    // - http://theorangeduck.com/page/avoiding-shader-conditionals\n    branchAvoidanceFunctions: [\n        'float when_gt(float x, float y) {',\n        '    return max(sign(x - y), 0.0);',\n        '}',\n\n        'float when_lt(float x, float y) {',\n        '    return min( max(1.0 - sign(x - y), 0.0), 1.0 );',\n        '}',\n\n        'float when_eq( float x, float y ) {',\n        '    return 1.0 - abs( sign( x - y ) );',\n        '}',\n\n        'float when_ge(float x, float y) {',\n        '  return 1.0 - when_lt(x, y);',\n        '}',\n\n        'float when_le(float x, float y) {',\n        '  return 1.0 - when_gt(x, y);',\n        '}',\n\n        // Branch-avoiding logical operators\n        // (to be used with above comparison fns)\n        'float and(float a, float b) {',\n        '    return a * b;',\n        '}',\n\n        'float or(float a, float b) {',\n        '    return min(a + b, 1.0);',\n        '}',\n    ].join( '\\n' ),\n\n\n    // From:\n    // - http://stackoverflow.com/a/12553149\n    // - https://stackoverflow.com/questions/22895237/hexadecimal-to-rgb-values-in-webgl-shader\n    unpackColor: [\n        'vec3 unpackColor( in float hex ) {',\n        '   vec3 c = vec3( 0.0 );',\n\n        '   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );',\n        '   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );',\n        '   float b = mod( hex, PACKED_COLOR_SIZE );',\n\n        '   c.r = r / PACKED_COLOR_DIVISOR;',\n        '   c.g = g / PACKED_COLOR_DIVISOR;',\n        '   c.b = b / PACKED_COLOR_DIVISOR;',\n\n        '   return c;',\n        '}',\n    ].join( '\\n' ),\n\n    unpackRotationAxis: [\n        'vec3 unpackRotationAxis( in float hex ) {',\n        '   vec3 c = vec3( 0.0 );',\n\n        '   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );',\n        '   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );',\n        '   float b = mod( hex, PACKED_COLOR_SIZE );',\n\n        '   c.r = r / PACKED_COLOR_DIVISOR;',\n        '   c.g = g / PACKED_COLOR_DIVISOR;',\n        '   c.b = b / PACKED_COLOR_DIVISOR;',\n\n        '   c *= vec3( 2.0 );',\n        '   c -= vec3( 1.0 );',\n\n        '   return c;',\n        '}',\n    ].join( '\\n' ),\n\n    floatOverLifetime: [\n        'float getFloatOverLifetime( in float positionInTime, in vec4 attr ) {',\n        '    highp float value = 0.0;',\n        '    float deltaAge = positionInTime * float( VALUE_OVER_LIFETIME_LENGTH - 1 );',\n        '    float fIndex = 0.0;',\n        '    float shouldApplyValue = 0.0;',\n\n        // This might look a little odd, but it's faster in the testing I've done than using branches.\n        // Uses basic maths to avoid branching.\n        //\n        // Take a look at the branch-avoidance functions defined above,\n        // and be sure to check out The Orange Duck site where I got this\n        // from (link above).\n\n        // Fix for static emitters (age is always zero).\n        '    value += attr[ 0 ] * when_eq( deltaAge, 0.0 );',\n        '',\n        '    for( int i = 0; i < VALUE_OVER_LIFETIME_LENGTH - 1; ++i ) {',\n        '       fIndex = float( i );',\n        '       shouldApplyValue = and( when_gt( deltaAge, fIndex ), when_le( deltaAge, fIndex + 1.0 ) );',\n        '       value += shouldApplyValue * mix( attr[ i ], attr[ i + 1 ], deltaAge - fIndex );',\n        '    }',\n        '',\n        '    return value;',\n        '}',\n    ].join( '\\n' ),\n\n    colorOverLifetime: [\n        'vec3 getColorOverLifetime( in float positionInTime, in vec3 color1, in vec3 color2, in vec3 color3, in vec3 color4 ) {',\n        '    vec3 value = vec3( 0.0 );',\n        '    value.x = getFloatOverLifetime( positionInTime, vec4( color1.x, color2.x, color3.x, color4.x ) );',\n        '    value.y = getFloatOverLifetime( positionInTime, vec4( color1.y, color2.y, color3.y, color4.y ) );',\n        '    value.z = getFloatOverLifetime( positionInTime, vec4( color1.z, color2.z, color3.z, color4.z ) );',\n        '    return value;',\n        '}',\n    ].join( '\\n' ),\n\n    paramFetchingFunctions: [\n        'float getAlive() {',\n        '   return params.x;',\n        '}',\n\n        'float getAge() {',\n        '   return params.y;',\n        '}',\n\n        'float getMaxAge() {',\n        '   return params.z;',\n        '}',\n\n        'float getWiggle() {',\n        '   return params.w;',\n        '}',\n    ].join( '\\n' ),\n\n    forceFetchingFunctions: [\n        'vec4 getPosition( in float age ) {',\n        '   return modelViewMatrix * vec4( position, 1.0 );',\n        '}',\n\n        'vec3 getVelocity( in float age ) {',\n        '   return velocity * age;',\n        '}',\n\n        'vec3 getAcceleration( in float age ) {',\n        '   return acceleration.xyz * age;',\n        '}',\n    ].join( '\\n' ),\n\n\n    rotationFunctions: [\n        // Huge thanks to:\n        // - http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n        '#ifdef SHOULD_ROTATE_PARTICLES',\n        '   mat4 getRotationMatrix( in vec3 axis, in float angle) {',\n        '       axis = normalize(axis);',\n        '       float s = sin(angle);',\n        '       float c = cos(angle);',\n        '       float oc = 1.0 - c;',\n        '',\n        '       return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,',\n        '                   oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,',\n        '                   oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,',\n        '                   0.0,                                0.0,                                0.0,                                1.0);',\n        '   }',\n        '',\n        '   vec3 getRotation( in vec3 pos, in float positionInTime ) {',\n        '      if( rotation.y == 0.0 ) {',\n        '           return pos;',\n        '      }',\n        '',\n        '      vec3 axis = unpackRotationAxis( rotation.x );',\n        '      vec3 center = rotationCenter;',\n        '      vec3 translated;',\n        '      mat4 rotationMatrix;',\n\n        '      float angle = 0.0;',\n        '      angle += when_eq( rotation.z, 0.0 ) * rotation.y;',\n        '      angle += when_gt( rotation.z, 0.0 ) * mix( 0.0, rotation.y, positionInTime );',\n        '      translated = rotationCenter - pos;',\n        '      rotationMatrix = getRotationMatrix( axis, angle );',\n        '      return center - vec3( rotationMatrix * vec4( translated, 0.0 ) );',\n        '   }',\n        '#endif'\n    ].join( '\\n' ),\n\n\n    // Fragment chunks\n    rotateTexture: [\n        '    vec2 vUv = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );',\n        '',\n        '    #ifdef SHOULD_ROTATE_TEXTURE',\n        '       float x = gl_PointCoord.x - 0.5;',\n        '       float y = 1.0 - gl_PointCoord.y - 0.5;',\n        '       float c = cos( -vAngle );',\n        '       float s = sin( -vAngle );',\n\n        '       vUv = vec2( c * x + s * y + 0.5, c * y - s * x + 0.5 );',\n        '    #endif',\n        '',\n\n        // Spritesheets overwrite angle calculations.\n        '    #ifdef SHOULD_CALCULATE_SPRITE',\n        '        float framesX = vSpriteSheet.x;',\n        '        float framesY = vSpriteSheet.y;',\n        '        float columnNorm = vSpriteSheet.z;',\n        '        float rowNorm = vSpriteSheet.w;',\n\n        '        vUv.x = gl_PointCoord.x * framesX + columnNorm;',\n        '        vUv.y = 1.0 - (gl_PointCoord.y * framesY + rowNorm);',\n        '    #endif',\n\n        '',\n        '    vec4 rotatedTexture = texture2D( texture, vUv );',\n    ].join( '\\n' )\n};\n\nSPE.shaders = {\n    vertex: [\n        SPE.shaderChunks.defines,\n        SPE.shaderChunks.uniforms,\n        SPE.shaderChunks.attributes,\n        SPE.shaderChunks.varyings,\n\n        THREE.ShaderChunk.common,\n        THREE.ShaderChunk.logdepthbuf_pars_vertex,\n        THREE.ShaderChunk.fog_pars_vertex,\n\n        SPE.shaderChunks.branchAvoidanceFunctions,\n        SPE.shaderChunks.unpackColor,\n        SPE.shaderChunks.unpackRotationAxis,\n        SPE.shaderChunks.floatOverLifetime,\n        SPE.shaderChunks.colorOverLifetime,\n        SPE.shaderChunks.paramFetchingFunctions,\n        SPE.shaderChunks.forceFetchingFunctions,\n        SPE.shaderChunks.rotationFunctions,\n\n\n        'vec4 mvPosition;',\n        'void main() {',\n\n\n        //\n        // Setup...\n        //\n        '    highp float age = getAge();',\n        '    highp float alive = getAlive();',\n        '    highp float maxAge = getMaxAge();',\n        '    highp float positionInTime = (age / maxAge);',\n        '    highp float isAlive = when_gt( alive, 0.0 );',\n\n        '    #ifdef SHOULD_WIGGLE_PARTICLES',\n        '        float wiggleAmount = positionInTime * getWiggle();',\n        '        float wiggleSin = isAlive * sin( wiggleAmount );',\n        '        float wiggleCos = isAlive * cos( wiggleAmount );',\n        '    #endif',\n\n        //\n        // Forces\n        //\n\n        // Get forces & position\n        '    vec3 vel = getVelocity( age );',\n        '    vec3 accel = getAcceleration( age );',\n        '    vec3 force = vec3( 0.0 );',\n        '    vec3 pos = vec3( position );',\n\n        // Calculate the required drag to apply to the forces.\n        '    float drag = 1.0 - (positionInTime * 0.5) * acceleration.w;',\n\n        // Integrate forces...\n        '    force += vel;',\n        '    force *= drag;',\n        '    force += accel * age;',\n        '    pos += force;',\n\n\n        // Wiggly wiggly wiggle!\n        '    #ifdef SHOULD_WIGGLE_PARTICLES',\n        '        pos.x += wiggleSin;',\n        '        pos.y += wiggleCos;',\n        '        pos.z += wiggleSin;',\n        '    #endif',\n\n\n        // Rotate the emitter around it's central point\n        '    #ifdef SHOULD_ROTATE_PARTICLES',\n        '        pos = getRotation( pos, positionInTime );',\n        '    #endif',\n\n        // Convert pos to a world-space value\n        '    vec4 mvPos = mvPosition = modelViewMatrix * vec4( pos, 1.0 );',\n\n        // Determine point size.\n        '    highp float pointSize = getFloatOverLifetime( positionInTime, size ) * isAlive;',\n\n        // Determine perspective\n        '    #ifdef HAS_PERSPECTIVE',\n        '        float perspective = scale / length( mvPos.xyz );',\n        '    #else',\n        '        float perspective = 1.0;',\n        '    #endif',\n\n        // Apply perpective to pointSize value\n        '    float pointSizePerspective = pointSize * perspective;',\n\n\n        //\n        // Appearance\n        //\n\n        // Determine color and opacity for this particle\n        '    #ifdef COLORIZE',\n        '       vec3 c = isAlive * getColorOverLifetime(',\n        '           positionInTime,',\n        '           unpackColor( color.x ),',\n        '           unpackColor( color.y ),',\n        '           unpackColor( color.z ),',\n        '           unpackColor( color.w )',\n        '       );',\n        '    #else',\n        '       vec3 c = vec3(1.0);',\n        '    #endif',\n\n        '    float o = isAlive * getFloatOverLifetime( positionInTime, opacity );',\n\n        // Assign color to vColor varying.\n        '    vColor = vec4( c, o );',\n\n        // Determine angle\n        '    #ifdef SHOULD_ROTATE_TEXTURE',\n        '        vAngle = isAlive * getFloatOverLifetime( positionInTime, angle );',\n        '    #endif',\n\n        // If this particle is using a sprite-sheet as a texture, we'll have to figure out\n        // what frame of the texture the particle is using at it's current position in time.\n        '    #ifdef SHOULD_CALCULATE_SPRITE',\n        '        float framesX = textureAnimation.x;',\n        '        float framesY = textureAnimation.y;',\n        '        float loopCount = textureAnimation.w;',\n        '        float totalFrames = textureAnimation.z;',\n        '        float frameNumber = mod( (positionInTime * loopCount) * totalFrames, totalFrames );',\n\n        '        float column = floor(mod( frameNumber, framesX ));',\n        '        float row = floor( (frameNumber - column) / framesX );',\n\n        '        float columnNorm = column / framesX;',\n        '        float rowNorm = row / framesY;',\n\n        '        vSpriteSheet.x = 1.0 / framesX;',\n        '        vSpriteSheet.y = 1.0 / framesY;',\n        '        vSpriteSheet.z = columnNorm;',\n        '        vSpriteSheet.w = rowNorm;',\n        '    #endif',\n\n        //\n        // Write values\n        //\n\n        // Set PointSize according to size at current point in time.\n        '    gl_PointSize = pointSizePerspective;',\n        '    gl_Position = projectionMatrix * mvPos;',\n\n        THREE.ShaderChunk.logdepthbuf_vertex,\n        THREE.ShaderChunk.fog_vertex,\n\n        '}'\n    ].join( '\\n' ),\n\n    fragment: [\n        SPE.shaderChunks.uniforms,\n\n        THREE.ShaderChunk.common,\n        THREE.ShaderChunk.fog_pars_fragment,\n        THREE.ShaderChunk.logdepthbuf_pars_fragment,\n\n        SPE.shaderChunks.varyings,\n\n        SPE.shaderChunks.branchAvoidanceFunctions,\n\n        'void main() {',\n        '    vec3 outgoingLight = vColor.xyz;',\n        '    ',\n        '    #ifdef ALPHATEST',\n        '       if ( vColor.w < float(ALPHATEST) ) discard;',\n        '    #endif',\n\n        SPE.shaderChunks.rotateTexture,\n\n        THREE.ShaderChunk.logdepthbuf_fragment,\n\n        '    outgoingLight = vColor.xyz * rotatedTexture.xyz;',\n\t\t'    gl_FragColor = vec4( outgoingLight.xyz, rotatedTexture.w * vColor.w );',\n\n        THREE.ShaderChunk.fog_fragment,\n\n        '}'\n    ].join( '\\n' )\n};\n\n/**\n * A bunch of utility functions used throughout the library.\n * @namespace\n * @type {Object}\n */\nSPE.utils = {\n    /**\n     * A map of types used by `SPE.utils.ensureTypedArg` and\n     * `SPE.utils.ensureArrayTypedArg` to compare types against.\n     *\n     * @enum {String}\n     */\n    types: {\n        /**\n         * Boolean type.\n         * @type {String}\n         */\n        BOOLEAN: 'boolean',\n\n        /**\n         * String type.\n         * @type {String}\n         */\n        STRING: 'string',\n\n        /**\n         * Number type.\n         * @type {String}\n         */\n        NUMBER: 'number',\n\n        /**\n         * Object type.\n         * @type {String}\n         */\n        OBJECT: 'object'\n    },\n\n    /**\n     * Given a value, a type, and a default value to fallback to,\n     * ensure the given argument adheres to the type requesting,\n     * returning the default value if type check is false.\n     *\n     * @param  {(boolean|string|number|object)} arg          The value to perform a type-check on.\n     * @param  {String} type         The type the `arg` argument should adhere to.\n     * @param  {(boolean|string|number|object)} defaultValue A default value to fallback on if the type check fails.\n     * @return {(boolean|string|number|object)}              The given value if type check passes, or the default value if it fails.\n     */\n    ensureTypedArg: function( arg, type, defaultValue ) {\n        'use strict';\n\n        if ( typeof arg === type ) {\n            return arg;\n        }\n        else {\n            return defaultValue;\n        }\n    },\n\n    /**\n     * Given an array of values, a type, and a default value,\n     * ensure the given array's contents ALL adhere to the provided type,\n     * returning the default value if type check fails.\n     *\n     * If the given value to check isn't an Array, delegates to SPE.utils.ensureTypedArg.\n     *\n     * @param  {Array|boolean|string|number|object} arg          The array of values to check type of.\n     * @param  {String} type         The type that should be adhered to.\n     * @param  {(boolean|string|number|object)} defaultValue A default fallback value.\n     * @return {(boolean|string|number|object)}              The given value if type check passes, or the default value if it fails.\n     */\n    ensureArrayTypedArg: function( arg, type, defaultValue ) {\n        'use strict';\n\n        // If the argument being checked is an array, loop through\n        // it and ensure all the values are of the correct type,\n        // falling back to the defaultValue if any aren't.\n        if ( Array.isArray( arg ) ) {\n            for ( var i = arg.length - 1; i >= 0; --i ) {\n                if ( typeof arg[ i ] !== type ) {\n                    return defaultValue;\n                }\n            }\n\n            return arg;\n        }\n\n        // If the arg isn't an array then just fallback to\n        // checking the type.\n        return this.ensureTypedArg( arg, type, defaultValue );\n    },\n\n    /**\n     * Ensures the given value is an instance of a constructor function.\n     *\n     * @param  {Object} arg          The value to check instance of.\n     * @param  {Function} instance     The constructor of the instance to check against.\n     * @param  {Object} defaultValue A default fallback value if instance check fails\n     * @return {Object}              The given value if type check passes, or the default value if it fails.\n     */\n    ensureInstanceOf: function( arg, instance, defaultValue ) {\n        'use strict';\n\n        if ( instance !== undefined && arg instanceof instance ) {\n            return arg;\n        }\n        else {\n            return defaultValue;\n        }\n    },\n\n    /**\n     * Given an array of values, ensure the instances of all items in the array\n     * matches the given instance constructor falling back to a default value if\n     * the check fails.\n     *\n     * If given value isn't an Array, delegates to `SPE.utils.ensureInstanceOf`.\n     *\n     * @param  {Array|Object} arg          The value to perform the instanceof check on.\n     * @param  {Function} instance     The constructor of the instance to check against.\n     * @param  {Object} defaultValue A default fallback value if instance check fails\n     * @return {Object}              The given value if type check passes, or the default value if it fails.\n     */\n    ensureArrayInstanceOf: function( arg, instance, defaultValue ) {\n        'use strict';\n\n        // If the argument being checked is an array, loop through\n        // it and ensure all the values are of the correct type,\n        // falling back to the defaultValue if any aren't.\n        if ( Array.isArray( arg ) ) {\n            for ( var i = arg.length - 1; i >= 0; --i ) {\n                if ( instance !== undefined && arg[ i ] instanceof instance === false ) {\n                    return defaultValue;\n                }\n            }\n\n            return arg;\n        }\n\n        // If the arg isn't an array then just fallback to\n        // checking the type.\n        return this.ensureInstanceOf( arg, instance, defaultValue );\n    },\n\n    /**\n     * Ensures that any \"value-over-lifetime\" properties of an emitter are\n     * of the correct length (as dictated by `SPE.valueOverLifetimeLength`).\n     *\n     * Delegates to `SPE.utils.interpolateArray` for array resizing.\n     *\n     * If properties aren't arrays, then property values are put into one.\n     *\n     * @param  {Object} property  The property of an SPE.Emitter instance to check compliance of.\n     * @param  {Number} minLength The minimum length of the array to create.\n     * @param  {Number} maxLength The maximum length of the array to create.\n     */\n    ensureValueOverLifetimeCompliance: function( property, minLength, maxLength ) {\n        'use strict';\n\n        minLength = minLength || 3;\n        maxLength = maxLength || 3;\n\n        // First, ensure both properties are arrays.\n        if ( Array.isArray( property._value ) === false ) {\n            property._value = [ property._value ];\n        }\n\n        if ( Array.isArray( property._spread ) === false ) {\n            property._spread = [ property._spread ];\n        }\n\n        var valueLength = this.clamp( property._value.length, minLength, maxLength ),\n            spreadLength = this.clamp( property._spread.length, minLength, maxLength ),\n            desiredLength = Math.max( valueLength, spreadLength );\n\n        if ( property._value.length !== desiredLength ) {\n            property._value = this.interpolateArray( property._value, desiredLength );\n        }\n\n        if ( property._spread.length !== desiredLength ) {\n            property._spread = this.interpolateArray( property._spread, desiredLength );\n        }\n    },\n\n    /**\n     * Performs linear interpolation (lerp) on an array.\n     *\n     * For example, lerping [1, 10], with a `newLength` of 10 will produce [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].\n     *\n     * Delegates to `SPE.utils.lerpTypeAgnostic` to perform the actual\n     * interpolation.\n     *\n     * @param  {Array} srcArray  The array to lerp.\n     * @param  {Number} newLength The length the array should be interpolated to.\n     * @return {Array}           The interpolated array.\n     */\n    interpolateArray: function( srcArray, newLength ) {\n        'use strict';\n\n        var sourceLength = srcArray.length,\n            newArray = [ typeof srcArray[ 0 ].clone === 'function' ? srcArray[ 0 ].clone() : srcArray[ 0 ] ],\n            factor = ( sourceLength - 1 ) / ( newLength - 1 );\n\n\n        for ( var i = 1; i < newLength - 1; ++i ) {\n            var f = i * factor,\n                before = Math.floor( f ),\n                after = Math.ceil( f ),\n                delta = f - before;\n\n            newArray[ i ] = this.lerpTypeAgnostic( srcArray[ before ], srcArray[ after ], delta );\n        }\n\n        newArray.push(\n            typeof srcArray[ sourceLength - 1 ].clone === 'function' ?\n            srcArray[ sourceLength - 1 ].clone() :\n            srcArray[ sourceLength - 1 ]\n        );\n\n        return newArray;\n    },\n\n    /**\n     * Clamp a number to between the given min and max values.\n     * @param  {Number} value The number to clamp.\n     * @param  {Number} min   The minimum value.\n     * @param  {Number} max   The maximum value.\n     * @return {Number}       The clamped number.\n     */\n    clamp: function( value, min, max ) {\n        'use strict';\n\n        return Math.max( min, Math.min( value, max ) );\n    },\n\n    /**\n     * If the given value is less than the epsilon value, then return\n     * a randomised epsilon value if specified, or just the epsilon value if not.\n     * Works for negative numbers as well as positive.\n     *\n     * @param  {Number} value     The value to perform the operation on.\n     * @param  {Boolean} randomise Whether the value should be randomised.\n     * @return {Number}           The result of the operation.\n     */\n    zeroToEpsilon: function( value, randomise ) {\n        'use strict';\n\n        var epsilon = 0.00001,\n            result = value;\n\n        result = randomise ? Math.random() * epsilon * 10 : epsilon;\n\n        if ( value < 0 && value > -epsilon ) {\n            result = -result;\n        }\n\n        // if ( value === 0 ) {\n        //     result = randomise ? Math.random() * epsilon * 10 : epsilon;\n        // }\n        // else if ( value > 0 && value < epsilon ) {\n        //     result = randomise ? Math.random() * epsilon * 10 : epsilon;\n        // }\n        // else if ( value < 0 && value > -epsilon ) {\n        //     result = -( randomise ? Math.random() * epsilon * 10 : epsilon );\n        // }\n\n        return result;\n    },\n\n    /**\n     * Linearly interpolates two values of various types. The given values\n     * must be of the same type for the interpolation to work.\n     * @param  {(number|Object)} start The start value of the lerp.\n     * @param  {(number|object)} end   The end value of the lerp.\n     * @param  {Number} delta The delta posiiton of the lerp operation. Ideally between 0 and 1 (inclusive).\n     * @return {(number|object|undefined)}       The result of the operation. Result will be undefined if\n     *                                               the start and end arguments aren't a supported type, or\n     *                                               if their types do not match.\n     */\n    lerpTypeAgnostic: function( start, end, delta ) {\n        'use strict';\n\n        var types = this.types,\n            out;\n\n        if ( typeof start === types.NUMBER && typeof end === types.NUMBER ) {\n            return start + ( ( end - start ) * delta );\n        }\n        else if ( start instanceof THREE.Vector2 && end instanceof THREE.Vector2 ) {\n            out = start.clone();\n            out.x = this.lerp( start.x, end.x, delta );\n            out.y = this.lerp( start.y, end.y, delta );\n            return out;\n        }\n        else if ( start instanceof THREE.Vector3 && end instanceof THREE.Vector3 ) {\n            out = start.clone();\n            out.x = this.lerp( start.x, end.x, delta );\n            out.y = this.lerp( start.y, end.y, delta );\n            out.z = this.lerp( start.z, end.z, delta );\n            return out;\n        }\n        else if ( start instanceof THREE.Vector4 && end instanceof THREE.Vector4 ) {\n            out = start.clone();\n            out.x = this.lerp( start.x, end.x, delta );\n            out.y = this.lerp( start.y, end.y, delta );\n            out.z = this.lerp( start.z, end.z, delta );\n            out.w = this.lerp( start.w, end.w, delta );\n            return out;\n        }\n        else if ( start instanceof THREE.Color && end instanceof THREE.Color ) {\n            out = start.clone();\n            out.r = this.lerp( start.r, end.r, delta );\n            out.g = this.lerp( start.g, end.g, delta );\n            out.b = this.lerp( start.b, end.b, delta );\n            return out;\n        }\n        else {\n            console.warn( 'Invalid argument types, or argument types do not match:', start, end );\n        }\n    },\n\n    /**\n     * Perform a linear interpolation operation on two numbers.\n     * @param  {Number} start The start value.\n     * @param  {Number} end   The end value.\n     * @param  {Number} delta The position to interpolate to.\n     * @return {Number}       The result of the lerp operation.\n     */\n    lerp: function( start, end, delta ) {\n        'use strict';\n        return start + ( ( end - start ) * delta );\n    },\n\n    /**\n     * Rounds a number to a nearest multiple.\n     *\n     * @param  {Number} n        The number to round.\n     * @param  {Number} multiple The multiple to round to.\n     * @return {Number}          The result of the round operation.\n     */\n    roundToNearestMultiple: function( n, multiple ) {\n        'use strict';\n\n        var remainder = 0;\n\n        if ( multiple === 0 ) {\n            return n;\n        }\n\n        remainder = Math.abs( n ) % multiple;\n\n        if ( remainder === 0 ) {\n            return n;\n        }\n\n        if ( n < 0 ) {\n            return -( Math.abs( n ) - remainder );\n        }\n\n        return n + multiple - remainder;\n    },\n\n    /**\n     * Check if all items in an array are equal. Uses strict equality.\n     *\n     * @param  {Array} array The array of values to check equality of.\n     * @return {Boolean}       Whether the array's values are all equal or not.\n     */\n    arrayValuesAreEqual: function( array ) {\n        'use strict';\n\n        for ( var i = 0; i < array.length - 1; ++i ) {\n            if ( array[ i ] !== array[ i + 1 ] ) {\n                return false;\n            }\n        }\n\n        return true;\n    },\n\n    // colorsAreEqual: function() {\n    //     var colors = Array.prototype.slice.call( arguments ),\n    //         numColors = colors.length;\n\n    //     for ( var i = 0, color1, color2; i < numColors - 1; ++i ) {\n    //         color1 = colors[ i ];\n    //         color2 = colors[ i + 1 ];\n\n    //         if (\n    //             color1.r !== color2.r ||\n    //             color1.g !== color2.g ||\n    //             color1.b !== color2.b\n    //         ) {\n    //             return false\n    //         }\n    //     }\n\n    //     return true;\n    // },\n\n\n    /**\n     * Given a start value and a spread value, create and return a random\n     * number.\n     * @param  {Number} base   The start value.\n     * @param  {Number} spread The size of the random variance to apply.\n     * @return {Number}        A randomised number.\n     */\n    randomFloat: function( base, spread ) {\n        'use strict';\n        return base + spread * ( Math.random() - 0.5 );\n    },\n\n\n\n    /**\n     * Given an SPE.ShaderAttribute instance, and various other settings,\n     * assign values to the attribute's array in a `vec3` format.\n     *\n     * @param  {Object} attribute   The instance of SPE.ShaderAttribute to save the result to.\n     * @param  {Number} index       The offset in the attribute's TypedArray to save the result from.\n     * @param  {Object} base        THREE.Vector3 instance describing the start value.\n     * @param  {Object} spread      THREE.Vector3 instance describing the random variance to apply to the start value.\n     * @param  {Object} spreadClamp THREE.Vector3 instance describing the multiples to clamp the randomness to.\n     */\n    randomVector3: function( attribute, index, base, spread, spreadClamp ) {\n        'use strict';\n\n        var x = base.x + ( Math.random() * spread.x - ( spread.x * 0.5 ) ),\n            y = base.y + ( Math.random() * spread.y - ( spread.y * 0.5 ) ),\n            z = base.z + ( Math.random() * spread.z - ( spread.z * 0.5 ) );\n\n        // var x = this.randomFloat( base.x, spread.x ),\n        // y = this.randomFloat( base.y, spread.y ),\n        // z = this.randomFloat( base.z, spread.z );\n\n        if ( spreadClamp ) {\n            x = -spreadClamp.x * 0.5 + this.roundToNearestMultiple( x, spreadClamp.x );\n            y = -spreadClamp.y * 0.5 + this.roundToNearestMultiple( y, spreadClamp.y );\n            z = -spreadClamp.z * 0.5 + this.roundToNearestMultiple( z, spreadClamp.z );\n        }\n\n        attribute.typedArray.setVec3Components( index, x, y, z );\n    },\n\n    /**\n     * Given an SPE.Shader attribute instance, and various other settings,\n     * assign Color values to the attribute.\n     * @param  {Object} attribute The instance of SPE.ShaderAttribute to save the result to.\n     * @param  {Number} index     The offset in the attribute's TypedArray to save the result from.\n     * @param  {Object} base      THREE.Color instance describing the start color.\n     * @param  {Object} spread    THREE.Vector3 instance describing the random variance to apply to the start color.\n     */\n    randomColor: function( attribute, index, base, spread ) {\n        'use strict';\n\n        var r = base.r + ( Math.random() * spread.x ),\n            g = base.g + ( Math.random() * spread.y ),\n            b = base.b + ( Math.random() * spread.z );\n\n        r = this.clamp( r, 0, 1 );\n        g = this.clamp( g, 0, 1 );\n        b = this.clamp( b, 0, 1 );\n\n\n        attribute.typedArray.setVec3Components( index, r, g, b );\n    },\n\n\n    randomColorAsHex: ( function() {\n        'use strict';\n\n        var workingColor = new THREE.Color();\n\n        /**\n         * Assigns a random color value, encoded as a hex value in decimal\n         * format, to a SPE.ShaderAttribute instance.\n         * @param  {Object} attribute The instance of SPE.ShaderAttribute to save the result to.\n         * @param  {Number} index     The offset in the attribute's TypedArray to save the result from.\n         * @param  {Object} base      THREE.Color instance describing the start color.\n         * @param  {Object} spread    THREE.Vector3 instance describing the random variance to apply to the start color.\n         */\n        return function( attribute, index, base, spread ) {\n            var numItems = base.length,\n                colors = [];\n\n            for ( var i = 0; i < numItems; ++i ) {\n                var spreadVector = spread[ i ];\n\n                workingColor.copy( base[ i ] );\n\n                workingColor.r += ( Math.random() * spreadVector.x ) - ( spreadVector.x * 0.5 );\n                workingColor.g += ( Math.random() * spreadVector.y ) - ( spreadVector.y * 0.5 );\n                workingColor.b += ( Math.random() * spreadVector.z ) - ( spreadVector.z * 0.5 );\n\n                workingColor.r = this.clamp( workingColor.r, 0, 1 );\n                workingColor.g = this.clamp( workingColor.g, 0, 1 );\n                workingColor.b = this.clamp( workingColor.b, 0, 1 );\n\n                colors.push( workingColor.getHex() );\n            }\n\n            attribute.typedArray.setVec4Components( index, colors[ 0 ], colors[ 1 ], colors[ 2 ], colors[ 3 ] );\n        };\n    }() ),\n\n    /**\n     * Assigns a random vector 3 value to an SPE.ShaderAttribute instance, projecting the\n     * given values onto a sphere.\n     *\n     * @param  {Object} attribute The instance of SPE.ShaderAttribute to save the result to.\n     * @param  {Number} index     The offset in the attribute's TypedArray to save the result from.\n     * @param  {Object} base              THREE.Vector3 instance describing the origin of the transform.\n     * @param  {Number} radius            The radius of the sphere to project onto.\n     * @param  {Number} radiusSpread      The amount of randomness to apply to the projection result\n     * @param  {Object} radiusScale       THREE.Vector3 instance describing the scale of each axis of the sphere.\n     * @param  {Number} radiusSpreadClamp What numeric multiple the projected value should be clamped to.\n     */\n    randomVector3OnSphere: function(\n        attribute, index, base, radius, radiusSpread, radiusScale, radiusSpreadClamp, distributionClamp\n    ) {\n        'use strict';\n\n        var depth = 2 * Math.random() - 1,\n            t = 6.2832 * Math.random(),\n            r = Math.sqrt( 1 - depth * depth ),\n            rand = this.randomFloat( radius, radiusSpread ),\n            x = 0,\n            y = 0,\n            z = 0;\n\n\n        if ( radiusSpreadClamp ) {\n            rand = Math.round( rand / radiusSpreadClamp ) * radiusSpreadClamp;\n        }\n\n\n\n        // Set position on sphere\n        x = r * Math.cos( t ) * rand;\n        y = r * Math.sin( t ) * rand;\n        z = depth * rand;\n\n        // Apply radius scale to this position\n        x *= radiusScale.x;\n        y *= radiusScale.y;\n        z *= radiusScale.z;\n\n        // Translate to the base position.\n        x += base.x;\n        y += base.y;\n        z += base.z;\n\n        // Set the values in the typed array.\n        attribute.typedArray.setVec3Components( index, x, y, z );\n    },\n\n    seededRandom: function( seed ) {\n        var x = Math.sin( seed ) * 10000;\n        return x - ( x | 0 );\n    },\n\n\n\n    /**\n     * Assigns a random vector 3 value to an SPE.ShaderAttribute instance, projecting the\n     * given values onto a 2d-disc.\n     *\n     * @param  {Object} attribute The instance of SPE.ShaderAttribute to save the result to.\n     * @param  {Number} index     The offset in the attribute's TypedArray to save the result from.\n     * @param  {Object} base              THREE.Vector3 instance describing the origin of the transform.\n     * @param  {Number} radius            The radius of the sphere to project onto.\n     * @param  {Number} radiusSpread      The amount of randomness to apply to the projection result\n     * @param  {Object} radiusScale       THREE.Vector3 instance describing the scale of each axis of the disc. The z-component is ignored.\n     * @param  {Number} radiusSpreadClamp What numeric multiple the projected value should be clamped to.\n     */\n    randomVector3OnDisc: function( attribute, index, base, radius, radiusSpread, radiusScale, radiusSpreadClamp ) {\n        'use strict';\n\n        var t = 6.2832 * Math.random(),\n            rand = Math.abs( this.randomFloat( radius, radiusSpread ) ),\n            x = 0,\n            y = 0,\n            z = 0;\n\n        if ( radiusSpreadClamp ) {\n            rand = Math.round( rand / radiusSpreadClamp ) * radiusSpreadClamp;\n        }\n\n        // Set position on sphere\n        x = Math.cos( t ) * rand;\n        y = Math.sin( t ) * rand;\n\n        // Apply radius scale to this position\n        x *= radiusScale.x;\n        y *= radiusScale.y;\n\n        // Translate to the base position.\n        x += base.x;\n        y += base.y;\n        z += base.z;\n\n        // Set the values in the typed array.\n        attribute.typedArray.setVec3Components( index, x, y, z );\n    },\n\n    randomDirectionVector3OnSphere: ( function() {\n        'use strict';\n\n        var v = new THREE.Vector3();\n\n        /**\n         * Given an SPE.ShaderAttribute instance, create a direction vector from the given\n         * position, using `speed` as the magnitude. Values are saved to the attribute.\n         *\n         * @param  {Object} attribute       The instance of SPE.ShaderAttribute to save the result to.\n         * @param  {Number} index           The offset in the attribute's TypedArray to save the result from.\n         * @param  {Number} posX            The particle's x coordinate.\n         * @param  {Number} posY            The particle's y coordinate.\n         * @param  {Number} posZ            The particle's z coordinate.\n         * @param  {Object} emitterPosition THREE.Vector3 instance describing the emitter's base position.\n         * @param  {Number} speed           The magnitude to apply to the vector.\n         * @param  {Number} speedSpread     The amount of randomness to apply to the magnitude.\n         */\n        return function( attribute, index, posX, posY, posZ, emitterPosition, speed, speedSpread ) {\n            v.copy( emitterPosition );\n\n            v.x -= posX;\n            v.y -= posY;\n            v.z -= posZ;\n\n            v.normalize().multiplyScalar( -this.randomFloat( speed, speedSpread ) );\n\n            attribute.typedArray.setVec3Components( index, v.x, v.y, v.z );\n        };\n    }() ),\n\n\n    randomDirectionVector3OnDisc: ( function() {\n        'use strict';\n\n        var v = new THREE.Vector3();\n\n        /**\n         * Given an SPE.ShaderAttribute instance, create a direction vector from the given\n         * position, using `speed` as the magnitude. Values are saved to the attribute.\n         *\n         * @param  {Object} attribute       The instance of SPE.ShaderAttribute to save the result to.\n         * @param  {Number} index           The offset in the attribute's TypedArray to save the result from.\n         * @param  {Number} posX            The particle's x coordinate.\n         * @param  {Number} posY            The particle's y coordinate.\n         * @param  {Number} posZ            The particle's z coordinate.\n         * @param  {Object} emitterPosition THREE.Vector3 instance describing the emitter's base position.\n         * @param  {Number} speed           The magnitude to apply to the vector.\n         * @param  {Number} speedSpread     The amount of randomness to apply to the magnitude.\n         */\n        return function( attribute, index, posX, posY, posZ, emitterPosition, speed, speedSpread ) {\n            v.copy( emitterPosition );\n\n            v.x -= posX;\n            v.y -= posY;\n            v.z -= posZ;\n\n            v.normalize().multiplyScalar( -this.randomFloat( speed, speedSpread ) );\n\n            attribute.typedArray.setVec3Components( index, v.x, v.y, 0 );\n        };\n    }() ),\n\n    getPackedRotationAxis: ( function() {\n        'use strict';\n\n        var v = new THREE.Vector3(),\n            vSpread = new THREE.Vector3(),\n            c = new THREE.Color(),\n            addOne = new THREE.Vector3( 1, 1, 1 );\n\n        /**\n         * Given a rotation axis, and a rotation axis spread vector,\n         * calculate a randomised rotation axis, and pack it into\n         * a hexadecimal value represented in decimal form.\n         * @param  {Object} axis       THREE.Vector3 instance describing the rotation axis.\n         * @param  {Object} axisSpread THREE.Vector3 instance describing the amount of randomness to apply to the rotation axis.\n         * @return {Number}            The packed rotation axis, with randomness.\n         */\n        return function( axis, axisSpread ) {\n            v.copy( axis ).normalize();\n            vSpread.copy( axisSpread ).normalize();\n\n            v.x += ( -axisSpread.x * 0.5 ) + ( Math.random() * axisSpread.x );\n            v.y += ( -axisSpread.y * 0.5 ) + ( Math.random() * axisSpread.y );\n            v.z += ( -axisSpread.z * 0.5 ) + ( Math.random() * axisSpread.z );\n\n            // v.x = Math.abs( v.x );\n            // v.y = Math.abs( v.y );\n            // v.z = Math.abs( v.z );\n\n            v.normalize().add( addOne ).multiplyScalar( 0.5 );\n\n            c.setRGB( v.x, v.y, v.z );\n\n            return c.getHex();\n        };\n    }() )\n};\n\n/**\n * An SPE.Group instance.\n * @typedef {Object} Group\n * @see SPE.Group\n */\n\n/**\n * A map of options to configure an SPE.Group instance.\n * @typedef {Object} GroupOptions\n *\n * @property {Object} texture An object describing the texture used by the group.\n *\n * @property {Object} texture.value An instance of THREE.Texture.\n *\n * @property {Object=} texture.frames A THREE.Vector2 instance describing the number\n *                                    of frames on the x- and y-axis of the given texture.\n *                                    If not provided, the texture will NOT be treated as\n *                                    a sprite-sheet and as such will NOT be animated.\n *\n * @property {Number} [texture.frameCount=texture.frames.x * texture.frames.y] The total number of frames in the sprite-sheet.\n *                                                                   Allows for sprite-sheets that don't fill the entire\n *                                                                   texture.\n *\n * @property {Number} texture.loop The number of loops through the sprite-sheet that should\n *                                 be performed over the course of a single particle's lifetime.\n *\n * @property {Number} fixedTimeStep If no `dt` (or `deltaTime`) value is passed to this group's\n *                                  `tick()` function, this number will be used to move the particle\n *                                  simulation forward. Value in SECONDS.\n *\n * @property {Boolean} hasPerspective Whether the distance a particle is from the camera should affect\n *                                    the particle's size.\n *\n * @property {Boolean} colorize Whether the particles in this group should be rendered with color, or\n *                              whether the only color of particles will come from the provided texture.\n *\n * @property {Number} blending One of Three.js's blending modes to apply to this group's `ShaderMaterial`.\n *\n * @property {Boolean} transparent Whether these particle's should be rendered with transparency.\n *\n * @property {Number} alphaTest Sets the alpha value to be used when running an alpha test on the `texture.value` property. Value between 0 and 1.\n *\n * @property {Boolean} depthWrite Whether rendering the group has any effect on the depth buffer.\n *\n * @property {Boolean} depthTest Whether to have depth test enabled when rendering this group.\n *\n * @property {Boolean} fog Whether this group's particles should be affected by their scene's fog.\n *\n * @property {Number} scale The scale factor to apply to this group's particle sizes. Useful for\n *                          setting particle sizes to be relative to renderer size.\n */\n\n\n/**\n * The SPE.Group class. Creates a new group, containing a material, geometry, and mesh.\n *\n * @constructor\n * @param {GroupOptions} options A map of options to configure the group instance.\n */\nSPE.Group = function( options ) {\n    'use strict';\n\n    var utils = SPE.utils,\n        types = utils.types;\n\n    // Ensure we have a map of options to play with\n    options = utils.ensureTypedArg( options, types.OBJECT, {} );\n    options.texture = utils.ensureTypedArg( options.texture, types.OBJECT, {} );\n\n    // Assign a UUID to this instance\n    this.uuid = THREE.Math.generateUUID();\n\n    // If no `deltaTime` value is passed to the `SPE.Group.tick` function,\n    // the value of this property will be used to advance the simulation.\n    this.fixedTimeStep = utils.ensureTypedArg( options.fixedTimeStep, types.NUMBER, 0.016 );\n\n    // Set properties used in the uniforms map, starting with the\n    // texture stuff.\n    this.texture = utils.ensureInstanceOf( options.texture.value, THREE.Texture, null );\n    this.textureFrames = utils.ensureInstanceOf( options.texture.frames, THREE.Vector2, new THREE.Vector2( 1, 1 ) );\n    this.textureFrameCount = utils.ensureTypedArg( options.texture.frameCount, types.NUMBER, this.textureFrames.x * this.textureFrames.y );\n    this.textureLoop = utils.ensureTypedArg( options.texture.loop, types.NUMBER, 1 );\n    this.textureFrames.max( new THREE.Vector2( 1, 1 ) );\n\n    this.hasPerspective = utils.ensureTypedArg( options.hasPerspective, types.BOOLEAN, true );\n    this.colorize = utils.ensureTypedArg( options.colorize, types.BOOLEAN, true );\n\n    this.maxParticleCount = utils.ensureTypedArg( options.maxParticleCount, types.NUMBER, null );\n\n\n    // Set properties used to define the ShaderMaterial's appearance.\n    this.blending = utils.ensureTypedArg( options.blending, types.NUMBER, THREE.AdditiveBlending );\n    this.transparent = utils.ensureTypedArg( options.transparent, types.BOOLEAN, true );\n    this.alphaTest = parseFloat( utils.ensureTypedArg( options.alphaTest, types.NUMBER, 0.0 ) );\n    this.depthWrite = utils.ensureTypedArg( options.depthWrite, types.BOOLEAN, false );\n    this.depthTest = utils.ensureTypedArg( options.depthTest, types.BOOLEAN, true );\n    this.fog = utils.ensureTypedArg( options.fog, types.BOOLEAN, true );\n    this.scale = utils.ensureTypedArg( options.scale, types.NUMBER, 300 );\n\n    // Where emitter's go to curl up in a warm blanket and live\n    // out their days.\n    this.emitters = [];\n    this.emitterIDs = [];\n\n    // Create properties for use by the emitter pooling functions.\n    this._pool = [];\n    this._poolCreationSettings = null;\n    this._createNewWhenPoolEmpty = 0;\n\n    // Whether all attributes should be forced to updated\n    // their entire buffer contents on the next tick.\n    //\n    // Used when an emitter is removed.\n    this._attributesNeedRefresh = false;\n    this._attributesNeedDynamicReset = false;\n\n    this.particleCount = 0;\n\n\n    // Map of uniforms to be applied to the ShaderMaterial instance.\n    this.uniforms = {\n        texture: {\n            type: 't',\n            value: this.texture\n        },\n        textureAnimation: {\n            type: 'v4',\n            value: new THREE.Vector4(\n                this.textureFrames.x,\n                this.textureFrames.y,\n                this.textureFrameCount,\n                Math.max( Math.abs( this.textureLoop ), 1.0 )\n            )\n        },\n        fogColor: {\n            type: 'c',\n            value: null\n        },\n        fogNear: {\n            type: 'f',\n            value: 10\n        },\n        fogFar: {\n            type: 'f',\n            value: 200\n        },\n        fogDensity: {\n            type: 'f',\n            value: 0.5\n        },\n        deltaTime: {\n            type: 'f',\n            value: 0\n        },\n        runTime: {\n            type: 'f',\n            value: 0\n        },\n        scale: {\n            type: 'f',\n            value: this.scale\n        }\n    };\n\n    // Add some defines into the mix...\n    this.defines = {\n        HAS_PERSPECTIVE: this.hasPerspective,\n        COLORIZE: this.colorize,\n        VALUE_OVER_LIFETIME_LENGTH: SPE.valueOverLifetimeLength,\n\n        SHOULD_ROTATE_TEXTURE: false,\n        SHOULD_ROTATE_PARTICLES: false,\n        SHOULD_WIGGLE_PARTICLES: false,\n\n        SHOULD_CALCULATE_SPRITE: this.textureFrames.x > 1 || this.textureFrames.y > 1\n    };\n\n    // Map of all attributes to be applied to the particles.\n    //\n    // See SPE.ShaderAttribute for a bit more info on this bit.\n    this.attributes = {\n        position: new SPE.ShaderAttribute( 'v3', true ),\n        acceleration: new SPE.ShaderAttribute( 'v4', true ), // w component is drag\n        velocity: new SPE.ShaderAttribute( 'v3', true ),\n        rotation: new SPE.ShaderAttribute( 'v4', true ),\n        rotationCenter: new SPE.ShaderAttribute( 'v3', true ),\n        params: new SPE.ShaderAttribute( 'v4', true ), // Holds (alive, age, delay, wiggle)\n        size: new SPE.ShaderAttribute( 'v4', true ),\n        angle: new SPE.ShaderAttribute( 'v4', true ),\n        color: new SPE.ShaderAttribute( 'v4', true ),\n        opacity: new SPE.ShaderAttribute( 'v4', true )\n    };\n\n    this.attributeKeys = Object.keys( this.attributes );\n    this.attributeCount = this.attributeKeys.length;\n\n    // Create the ShaderMaterial instance that'll help render the\n    // particles.\n    this.material = new THREE.ShaderMaterial( {\n        uniforms: this.uniforms,\n        vertexShader: SPE.shaders.vertex,\n        fragmentShader: SPE.shaders.fragment,\n        blending: this.blending,\n        transparent: this.transparent,\n        alphaTest: this.alphaTest,\n        depthWrite: this.depthWrite,\n        depthTest: this.depthTest,\n        defines: this.defines,\n        fog: this.fog\n    } );\n\n    // Create the BufferGeometry and Points instances, ensuring\n    // the geometry and material are given to the latter.\n    this.geometry = new THREE.BufferGeometry();\n    this.mesh = new THREE.Points( this.geometry, this.material );\n\n    if ( this.maxParticleCount === null ) {\n        console.warn( 'SPE.Group: No maxParticleCount specified. Adding emitters after rendering will probably cause errors.' );\n    }\n};\n\nSPE.Group.constructor = SPE.Group;\n\n\nSPE.Group.prototype._updateDefines = function() {\n    'use strict';\n\n    var emitters = this.emitters,\n        i = emitters.length - 1,\n        emitter,\n        defines = this.defines;\n\n    for ( i; i >= 0; --i ) {\n        emitter = emitters[ i ];\n\n        // Only do angle calculation if there's no spritesheet defined.\n        //\n        // Saves calculations being done and then overwritten in the shaders.\n        if ( !defines.SHOULD_CALCULATE_SPRITE ) {\n            defines.SHOULD_ROTATE_TEXTURE = defines.SHOULD_ROTATE_TEXTURE || !!Math.max(\n                Math.max.apply( null, emitter.angle.value ),\n                Math.max.apply( null, emitter.angle.spread )\n            );\n        }\n\n        defines.SHOULD_ROTATE_PARTICLES = defines.SHOULD_ROTATE_PARTICLES || !!Math.max(\n            emitter.rotation.angle,\n            emitter.rotation.angleSpread\n        );\n\n        defines.SHOULD_WIGGLE_PARTICLES = defines.SHOULD_WIGGLE_PARTICLES || !!Math.max(\n            emitter.wiggle.value,\n            emitter.wiggle.spread\n        );\n    }\n\n    this.material.needsUpdate = true;\n};\n\nSPE.Group.prototype._applyAttributesToGeometry = function() {\n    'use strict';\n\n    var attributes = this.attributes,\n        geometry = this.geometry,\n        geometryAttributes = geometry.attributes,\n        attribute,\n        geometryAttribute;\n\n    // Loop through all the shader attributes and assign (or re-assign)\n    // typed array buffers to each one.\n    for ( var attr in attributes ) {\n        if ( attributes.hasOwnProperty( attr ) ) {\n            attribute = attributes[ attr ];\n            geometryAttribute = geometryAttributes[ attr ];\n\n            // Update the array if this attribute exists on the geometry.\n            //\n            // This needs to be done because the attribute's typed array might have\n            // been resized and reinstantiated, and might now be looking at a\n            // different ArrayBuffer, so reference needs updating.\n            if ( geometryAttribute ) {\n                geometryAttribute.array = attribute.typedArray.array;\n            }\n\n            // // Add the attribute to the geometry if it doesn't already exist.\n            else {\n                geometry.addAttribute( attr, attribute.bufferAttribute );\n            }\n\n            // Mark the attribute as needing an update the next time a frame is rendered.\n            attribute.bufferAttribute.needsUpdate = true;\n        }\n    }\n\n    // Mark the draw range on the geometry. This will ensure\n    // only the values in the attribute buffers that are\n    // associated with a particle will be used in THREE's\n    // render cycle.\n    this.geometry.setDrawRange( 0, this.particleCount );\n};\n\n/**\n * Adds an SPE.Emitter instance to this group, creating particle values and\n * assigning them to this group's shader attributes.\n *\n * @param {Emitter} emitter The emitter to add to this group.\n */\nSPE.Group.prototype.addEmitter = function( emitter ) {\n    'use strict';\n\n    // Ensure an actual emitter instance is passed here.\n    //\n    // Decided not to throw here, just in case a scene's\n    // rendering would be paused. Logging an error instead\n    // of stopping execution if exceptions aren't caught.\n    if ( emitter instanceof SPE.Emitter === false ) {\n        console.error( '`emitter` argument must be instance of SPE.Emitter. Was provided with:', emitter );\n        return;\n    }\n\n    // If the emitter already exists as a member of this group, then\n    // stop here, we don't want to add it again.\n    else if ( this.emitterIDs.indexOf( emitter.uuid ) > -1 ) {\n        console.error( 'Emitter already exists in this group. Will not add again.' );\n        return;\n    }\n\n    // And finally, if the emitter is a member of another group,\n    // don't add it to this group.\n    else if ( emitter.group !== null ) {\n        console.error( 'Emitter already belongs to another group. Will not add to requested group.' );\n        return;\n    }\n\n    var attributes = this.attributes,\n        start = this.particleCount,\n        end = start + emitter.particleCount;\n\n    // Update this group's particle count.\n    this.particleCount = end;\n\n    // Emit a warning if the emitter being added will exceed the buffer sizes specified.\n    if ( this.maxParticleCount !== null && this.particleCount > this.maxParticleCount ) {\n        console.warn( 'SPE.Group: maxParticleCount exceeded. Requesting', this.particleCount, 'particles, can support only', this.maxParticleCount );\n    }\n\n\n    // Set the `particlesPerSecond` value (PPS) on the emitter.\n    // It's used to determine how many particles to release\n    // on a per-frame basis.\n    emitter._calculatePPSValue( emitter.maxAge._value + emitter.maxAge._spread );\n    emitter._setBufferUpdateRanges( this.attributeKeys );\n\n    // Store the offset value in the TypedArray attributes for this emitter.\n    emitter._setAttributeOffset( start );\n\n    // Save a reference to this group on the emitter so it knows\n    // where it belongs.\n    emitter.group = this;\n\n    // Store reference to the attributes on the emitter for\n    // easier access during the emitter's tick function.\n    emitter.attributes = this.attributes;\n\n\n\n    // Ensure the attributes and their BufferAttributes exist, and their\n    // TypedArrays are of the correct size.\n    for ( var attr in attributes ) {\n        if ( attributes.hasOwnProperty( attr ) ) {\n            // When creating a buffer, pass through the maxParticle count\n            // if one is specified.\n            attributes[ attr ]._createBufferAttribute(\n                this.maxParticleCount !== null ?\n                this.maxParticleCount :\n                this.particleCount\n            );\n        }\n    }\n\n    // Loop through each particle this emitter wants to have, and create the attributes values,\n    // storing them in the TypedArrays that each attribute holds.\n    for ( var i = start; i < end; ++i ) {\n        emitter._assignPositionValue( i );\n        emitter._assignForceValue( i, 'velocity' );\n        emitter._assignForceValue( i, 'acceleration' );\n        emitter._assignAbsLifetimeValue( i, 'opacity' );\n        emitter._assignAbsLifetimeValue( i, 'size' );\n        emitter._assignAngleValue( i );\n        emitter._assignRotationValue( i );\n        emitter._assignParamsValue( i );\n        emitter._assignColorValue( i );\n    }\n\n    // Update the geometry and make sure the attributes are referencing\n    // the typed arrays properly.\n    this._applyAttributesToGeometry();\n\n    // Store this emitter in this group's emitter's store.\n    this.emitters.push( emitter );\n    this.emitterIDs.push( emitter.uuid );\n\n    // Update certain flags to enable shader calculations only if they're necessary.\n    this._updateDefines( emitter );\n\n    // Update the material since defines might have changed\n    this.material.needsUpdate = true;\n    this.geometry.needsUpdate = true;\n    this._attributesNeedRefresh = true;\n\n    // Return the group to enable chaining.\n    return this;\n};\n\n/**\n * Removes an SPE.Emitter instance from this group. When called,\n * all particle's belonging to the given emitter will be instantly\n * removed from the scene.\n *\n * @param {Emitter} emitter The emitter to add to this group.\n */\nSPE.Group.prototype.removeEmitter = function( emitter ) {\n    'use strict';\n\n    var emitterIndex = this.emitterIDs.indexOf( emitter.uuid );\n\n    // Ensure an actual emitter instance is passed here.\n    //\n    // Decided not to throw here, just in case a scene's\n    // rendering would be paused. Logging an error instead\n    // of stopping execution if exceptions aren't caught.\n    if ( emitter instanceof SPE.Emitter === false ) {\n        console.error( '`emitter` argument must be instance of SPE.Emitter. Was provided with:', emitter );\n        return;\n    }\n\n    // Issue an error if the emitter isn't a member of this group.\n    else if ( emitterIndex === -1 ) {\n        console.error( 'Emitter does not exist in this group. Will not remove.' );\n        return;\n    }\n\n    // Kill all particles by marking them as dead\n    // and their age as 0.\n    var start = emitter.attributeOffset,\n        end = start + emitter.particleCount,\n        params = this.attributes.params.typedArray;\n\n    // Set alive and age to zero.\n    for ( var i = start; i < end; ++i ) {\n        params.array[ i * 4 ] = 0.0;\n        params.array[ i * 4 + 1 ] = 0.0;\n    }\n\n    // Remove the emitter from this group's \"store\".\n    this.emitters.splice( emitterIndex, 1 );\n    this.emitterIDs.splice( emitterIndex, 1 );\n\n    // Remove this emitter's attribute values from all shader attributes.\n    // The `.splice()` call here also marks each attribute's buffer\n    // as needing to update it's entire contents.\n    for ( var attr in this.attributes ) {\n        if ( this.attributes.hasOwnProperty( attr ) ) {\n            this.attributes[ attr ].splice( start, end );\n        }\n    }\n\n    // Ensure this group's particle count is correct.\n    this.particleCount -= emitter.particleCount;\n\n    // Call the emitter's remove method.\n    emitter._onRemove();\n\n    // Set a flag to indicate that the attribute buffers should\n    // be updated in their entirety on the next frame.\n    this._attributesNeedRefresh = true;\n};\n\n\n/**\n * Fetch a single emitter instance from the pool.\n * If there are no objects in the pool, a new emitter will be\n * created if specified.\n *\n * @return {Emitter|null}\n */\nSPE.Group.prototype.getFromPool = function() {\n    'use strict';\n\n    var pool = this._pool,\n        createNew = this._createNewWhenPoolEmpty;\n\n    if ( pool.length ) {\n        return pool.pop();\n    }\n    else if ( createNew ) {\n        return new SPE.Emitter( this._poolCreationSettings );\n    }\n\n    return null;\n};\n\n\n/**\n * Release an emitter into the pool.\n *\n * @param  {ShaderParticleEmitter} emitter\n * @return {Group} This group instance.\n */\nSPE.Group.prototype.releaseIntoPool = function( emitter ) {\n    'use strict';\n\n    if ( emitter instanceof SPE.Emitter === false ) {\n        console.error( 'Argument is not instanceof SPE.Emitter:', emitter );\n        return;\n    }\n\n    emitter.reset();\n    this._pool.unshift( emitter );\n\n    return this;\n};\n\n\n/**\n * Get the pool array\n *\n * @return {Array}\n */\nSPE.Group.prototype.getPool = function() {\n    'use strict';\n    return this._pool;\n};\n\n\n/**\n * Add a pool of emitters to this particle group\n *\n * @param {Number} numEmitters      The number of emitters to add to the pool.\n * @param {EmitterOptions|Array} emitterOptions  An object, or array of objects, describing the options to pass to each emitter.\n * @param {Boolean} createNew       Should a new emitter be created if the pool runs out?\n * @return {Group} This group instance.\n */\nSPE.Group.prototype.addPool = function( numEmitters, emitterOptions, createNew ) {\n    'use strict';\n\n    var emitter;\n\n    // Save relevant settings and flags.\n    this._poolCreationSettings = emitterOptions;\n    this._createNewWhenPoolEmpty = !!createNew;\n\n    // Create the emitters, add them to this group and the pool.\n    for ( var i = 0; i < numEmitters; ++i ) {\n        if ( Array.isArray( emitterOptions ) ) {\n            emitter = new SPE.Emitter( emitterOptions[ i ] );\n        }\n        else {\n            emitter = new SPE.Emitter( emitterOptions );\n        }\n        this.addEmitter( emitter );\n        this.releaseIntoPool( emitter );\n    }\n\n    return this;\n};\n\n\n\nSPE.Group.prototype._triggerSingleEmitter = function( pos ) {\n    'use strict';\n\n    var emitter = this.getFromPool(),\n        self = this;\n\n    if ( emitter === null ) {\n        console.log( 'SPE.Group pool ran out.' );\n        return;\n    }\n\n    // TODO:\n    // - Make sure buffers are update with thus new position.\n    if ( pos instanceof THREE.Vector3 ) {\n        emitter.position.value.copy( pos );\n\n        // Trigger the setter for this property to force an\n        // update to the emitter's position attribute.\n        emitter.position.value = emitter.position.value;\n    }\n\n    emitter.enable();\n\n    setTimeout( function() {\n        emitter.disable();\n        self.releaseIntoPool( emitter );\n    }, ( Math.max( emitter.duration, ( emitter.maxAge.value + emitter.maxAge.spread ) ) ) * 1000 );\n\n    return this;\n};\n\n\n/**\n * Set a given number of emitters as alive, with an optional position\n * vector3 to move them to.\n *\n * @param  {Number} numEmitters The number of emitters to activate\n * @param  {Object} [position=undefined] A THREE.Vector3 instance describing the position to activate the emitter(s) at.\n * @return {Group} This group instance.\n */\nSPE.Group.prototype.triggerPoolEmitter = function( numEmitters, position ) {\n    'use strict';\n\n    if ( typeof numEmitters === 'number' && numEmitters > 1 ) {\n        for ( var i = 0; i < numEmitters; ++i ) {\n            this._triggerSingleEmitter( position );\n        }\n    }\n    else {\n        this._triggerSingleEmitter( position );\n    }\n\n    return this;\n};\n\n\n\nSPE.Group.prototype._updateUniforms = function( dt ) {\n    'use strict';\n\n    this.uniforms.runTime.value += dt;\n    this.uniforms.deltaTime.value = dt;\n};\n\nSPE.Group.prototype._resetBufferRanges = function() {\n    'use strict';\n\n    var keys = this.attributeKeys,\n        i = this.attributeCount - 1,\n        attrs = this.attributes;\n\n    for ( i; i >= 0; --i ) {\n        attrs[ keys[ i ] ].resetUpdateRange();\n    }\n};\n\n\nSPE.Group.prototype._updateBuffers = function( emitter ) {\n    'use strict';\n\n    var keys = this.attributeKeys,\n        i = this.attributeCount - 1,\n        attrs = this.attributes,\n        emitterRanges = emitter.bufferUpdateRanges,\n        key,\n        emitterAttr,\n        attr;\n\n    for ( i; i >= 0; --i ) {\n        key = keys[ i ];\n        emitterAttr = emitterRanges[ key ];\n        attr = attrs[ key ];\n        attr.setUpdateRange( emitterAttr.min, emitterAttr.max );\n        attr.flagUpdate();\n    }\n};\n\n\n/**\n * Simulate all the emitter's belonging to this group, updating\n * attribute values along the way.\n * @param  {Number} [dt=Group's `fixedTimeStep` value] The number of seconds to simulate the group's emitters for (deltaTime)\n */\nSPE.Group.prototype.tick = function( dt ) {\n    'use strict';\n\n    var emitters = this.emitters,\n        numEmitters = emitters.length,\n        deltaTime = dt || this.fixedTimeStep,\n        keys = this.attributeKeys,\n        i,\n        attrs = this.attributes;\n\n    // Update uniform values.\n    this._updateUniforms( deltaTime );\n\n    // Reset buffer update ranges on the shader attributes.\n    this._resetBufferRanges();\n\n\n    // If nothing needs updating, then stop here.\n    if (\n        numEmitters === 0 &&\n        this._attributesNeedRefresh === false &&\n        this._attributesNeedDynamicReset === false\n    ) {\n        return;\n    }\n\n    // Loop through each emitter in this group and\n    // simulate it, then update the shader attribute\n    // buffers.\n    for ( var i = 0, emitter; i < numEmitters; ++i ) {\n        emitter = emitters[ i ];\n        emitter.tick( deltaTime );\n        this._updateBuffers( emitter );\n    }\n\n    // If the shader attributes have been refreshed,\n    // then the dynamic properties of each buffer\n    // attribute will need to be reset back to\n    // what they should be.\n    if ( this._attributesNeedDynamicReset === true ) {\n        i = this.attributeCount - 1;\n\n        for ( i; i >= 0; --i ) {\n            attrs[ keys[ i ] ].resetDynamic();\n        }\n\n        this._attributesNeedDynamicReset = false;\n    }\n\n    // If this group's shader attributes need a full refresh\n    // then mark each attribute's buffer attribute as\n    // needing so.\n    if ( this._attributesNeedRefresh === true ) {\n        i = this.attributeCount - 1;\n\n        for ( i; i >= 0; --i ) {\n            attrs[ keys[ i ] ].forceUpdateAll();\n        }\n\n        this._attributesNeedRefresh = false;\n        this._attributesNeedDynamicReset = true;\n    }\n};\n\n\n/**\n * Dipose the geometry and material for the group.\n *\n * @return {Group} Group instance.\n */\nSPE.Group.prototype.dispose = function() {\n    'use strict';\n    this.geometry.dispose();\n    this.material.dispose();\n    return this;\n};\n\n/**\n * An SPE.Emitter instance.\n * @typedef {Object} Emitter\n * @see SPE.Emitter\n */\n\n/**\n * A map of options to configure an SPE.Emitter instance.\n *\n * @typedef {Object} EmitterOptions\n *\n * @property {distribution} [type=BOX] The default distribution this emitter should use to control\n *                         its particle's spawn position and force behaviour.\n *                         Must be an SPE.distributions.* value.\n *\n *\n * @property {Number} [particleCount=100] The total number of particles this emitter will hold. NOTE: this is not the number\n *                                  of particles emitted in a second, or anything like that. The number of particles\n *                                  emitted per-second is calculated by particleCount / maxAge (approximately!)\n *\n * @property {Number|null} [duration=null] The duration in seconds that this emitter should live for. If not specified, the emitter\n *                                         will emit particles indefinitely.\n *                                         NOTE: When an emitter is older than a specified duration, the emitter is NOT removed from\n *                                         it's group, but rather is just marked as dead, allowing it to be reanimated at a later time\n *                                         using `SPE.Emitter.prototype.enable()`.\n *\n * @property {Boolean} [isStatic=false] Whether this emitter should be not be simulated (true).\n * @property {Boolean} [activeMultiplier=1] A value between 0 and 1 describing what percentage of this emitter's particlesPerSecond should be\n *                                          emitted, where 0 is 0%, and 1 is 100%.\n *                                          For example, having an emitter with 100 particles, a maxAge of 2, yields a particlesPerSecond\n *                                          value of 50. Setting `activeMultiplier` to 0.5, then, will only emit 25 particles per second (0.5 = 50%).\n *                                          Values greater than 1 will emulate a burst of particles, causing the emitter to run out of particles\n *                                          before it's next activation cycle.\n *\n * @property {Boolean} [direction=1] The direction of the emitter. If value is `1`, emitter will start at beginning of particle's lifecycle.\n *                                   If value is `-1`, emitter will start at end of particle's lifecycle and work it's way backwards.\n *\n * @property {Object} [maxAge={}] An object describing the particle's maximum age in seconds.\n * @property {Number} [maxAge.value=2] A number between 0 and 1 describing the amount of maxAge to apply to all particles.\n * @property {Number} [maxAge.spread=0] A number describing the maxAge variance on a per-particle basis.\n *\n *\n * @property {Object} [position={}] An object describing this emitter's position.\n * @property {Object} [position.value=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's base position.\n * @property {Object} [position.spread=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's position variance on a per-particle basis.\n *                                                          Note that when using a SPHERE or DISC distribution, only the x-component\n *                                                          of this vector is used.\n * @property {Object} [position.spreadClamp=new THREE.Vector3()] A THREE.Vector3 instance describing the numeric multiples the particle's should\n *                                                               be spread out over.\n *                                                               Note that when using a SPHERE or DISC distribution, only the x-component\n *                                                               of this vector is used.\n * @property {Number} [position.radius=10] This emitter's base radius.\n * @property {Object} [position.radiusScale=new THREE.Vector3()] A THREE.Vector3 instance describing the radius's scale in all three axes. Allows a SPHERE or DISC to be squashed or stretched.\n * @property {distribution} [position.distribution=value of the `type` option.] A specific distribution to use when radiusing particles. Overrides the `type` option.\n * @property {Boolean} [position.randomise=false] When a particle is re-spawned, whether it's position should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [velocity={}] An object describing this particle velocity.\n * @property {Object} [velocity.value=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's base velocity.\n * @property {Object} [velocity.spread=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's velocity variance on a per-particle basis.\n *                                                          Note that when using a SPHERE or DISC distribution, only the x-component\n *                                                          of this vector is used.\n * @property {distribution} [velocity.distribution=value of the `type` option.] A specific distribution to use when calculating a particle's velocity. Overrides the `type` option.\n * @property {Boolean} [velocity.randomise=false] When a particle is re-spawned, whether it's velocity should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [acceleration={}] An object describing this particle's acceleration.\n * @property {Object} [acceleration.value=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's base acceleration.\n * @property {Object} [acceleration.spread=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's acceleration variance on a per-particle basis.\n *                           Note that when using a SPHERE or DISC distribution, only the x-component\n *                           of this vector is used.\n * @property {distribution} [acceleration.distribution=value of the `type` option.] A specific distribution to use when calculating a particle's acceleration. Overrides the `type` option.\n * @property {Boolean} [acceleration.randomise=false] When a particle is re-spawned, whether it's acceleration should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [drag={}] An object describing this particle drag. Drag is applied to both velocity and acceleration values.\n * @property {Number} [drag.value=0] A number between 0 and 1 describing the amount of drag to apply to all particles.\n * @property {Number} [drag.spread=0] A number describing the drag variance on a per-particle basis.\n * @property {Boolean} [drag.randomise=false] When a particle is re-spawned, whether it's drag should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [wiggle={}] This is quite a fun one! The values of this object will determine whether a particle will wiggle, or jiggle, or wave,\n *                                or shimmy, or waggle, or... Well you get the idea. The wiggle is calculated over-time, meaning that a particle will\n *                                start off with no wiggle, and end up wiggling about with the distance of the `value` specified by the time it dies.\n *                                It's quite handy to simulate fire embers, or similar effects where the particle's position should slightly change over\n *                                time, and such change isn't easily controlled by rotation, velocity, or acceleration. The wiggle is a combination of sin and cos calculations, so is circular in nature.\n * @property {Number} [wiggle.value=0] A number describing the amount of wiggle to apply to all particles. It's measured in distance.\n * @property {Number} [wiggle.spread=0] A number describing the wiggle variance on a per-particle basis.\n *\n *\n * @property {Object} [rotation={}] An object describing this emitter's rotation. It can either be static, or set to rotate from 0radians to the value of `rotation.value`\n *                                  over a particle's lifetime. Rotation values affect both a particle's position and the forces applied to it.\n * @property {Object} [rotation.axis=new THREE.Vector3(0, 1, 0)] A THREE.Vector3 instance describing this emitter's axis of rotation.\n * @property {Object} [rotation.axisSpread=new THREE.Vector3()] A THREE.Vector3 instance describing the amount of variance to apply to the axis of rotation on\n *                                                              a per-particle basis.\n * @property {Number} [rotation.angle=0] The angle of rotation, given in radians. If `rotation.static` is true, the emitter will start off rotated at this angle, and stay as such.\n *                                       Otherwise, the particles will rotate from 0radians to this value over their lifetimes.\n * @property {Number} [rotation.angleSpread=0] The amount of variance in each particle's rotation angle.\n * @property {Boolean} [rotation.static=false] Whether the rotation should be static or not.\n * @property {Object} [rotation.center=The value of `position.value`] A THREE.Vector3 instance describing the center point of rotation.\n * @property {Boolean} [rotation.randomise=false] When a particle is re-spawned, whether it's rotation should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [color={}] An object describing a particle's color. This property is a \"value-over-lifetime\" property, meaning an array of values and spreads can be\n *                               given to describe specific value changes over a particle's lifetime.\n *                               Depending on the value of SPE.valueOverLifetimeLength, if arrays of THREE.Color instances are given, then the array will be interpolated to\n *                               have a length matching the value of SPE.valueOverLifetimeLength.\n * @property {Object} [color.value=new THREE.Color()] Either a single THREE.Color instance, or an array of THREE.Color instances to describe the color of a particle over it's lifetime.\n * @property {Object} [color.spread=new THREE.Vector3()] Either a single THREE.Vector3 instance, or an array of THREE.Vector3 instances to describe the color variance of a particle over it's lifetime.\n * @property {Boolean} [color.randomise=false] When a particle is re-spawned, whether it's color should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [opacity={}] An object describing a particle's opacity. This property is a \"value-over-lifetime\" property, meaning an array of values and spreads can be\n *                               given to describe specific value changes over a particle's lifetime.\n *                               Depending on the value of SPE.valueOverLifetimeLength, if arrays of numbers are given, then the array will be interpolated to\n *                               have a length matching the value of SPE.valueOverLifetimeLength.\n * @property {Number} [opacity.value=1] Either a single number, or an array of numbers to describe the opacity of a particle over it's lifetime.\n * @property {Number} [opacity.spread=0] Either a single number, or an array of numbers to describe the opacity variance of a particle over it's lifetime.\n * @property {Boolean} [opacity.randomise=false] When a particle is re-spawned, whether it's opacity should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [size={}] An object describing a particle's size. This property is a \"value-over-lifetime\" property, meaning an array of values and spreads can be\n *                               given to describe specific value changes over a particle's lifetime.\n *                               Depending on the value of SPE.valueOverLifetimeLength, if arrays of numbers are given, then the array will be interpolated to\n *                               have a length matching the value of SPE.valueOverLifetimeLength.\n * @property {Number} [size.value=1] Either a single number, or an array of numbers to describe the size of a particle over it's lifetime.\n * @property {Number} [size.spread=0] Either a single number, or an array of numbers to describe the size variance of a particle over it's lifetime.\n * @property {Boolean} [size.randomise=false] When a particle is re-spawned, whether it's size should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [angle={}] An object describing a particle's angle. The angle is a 2d-rotation, measured in radians, applied to the particle's texture.\n *                               NOTE: if a particle's texture is a sprite-sheet, this value IS IGNORED.\n *                               This property is a \"value-over-lifetime\" property, meaning an array of values and spreads can be\n *                               given to describe specific value changes over a particle's lifetime.\n *                               Depending on the value of SPE.valueOverLifetimeLength, if arrays of numbers are given, then the array will be interpolated to\n *                               have a length matching the value of SPE.valueOverLifetimeLength.\n * @property {Number} [angle.value=0] Either a single number, or an array of numbers to describe the angle of a particle over it's lifetime.\n * @property {Number} [angle.spread=0] Either a single number, or an array of numbers to describe the angle variance of a particle over it's lifetime.\n * @property {Boolean} [angle.randomise=false] When a particle is re-spawned, whether it's angle should be re-randomised or not. Can incur a performance hit.\n *\n */\n\n/**\n * The SPE.Emitter class.\n *\n * @constructor\n *\n * @param {EmitterOptions} options A map of options to configure the emitter.\n */\nSPE.Emitter = function( options ) {\n    'use strict';\n\n    var utils = SPE.utils,\n        types = utils.types,\n        lifetimeLength = SPE.valueOverLifetimeLength;\n\n    // Ensure we have a map of options to play with,\n    // and that each option is in the correct format.\n    options = utils.ensureTypedArg( options, types.OBJECT, {} );\n    options.position = utils.ensureTypedArg( options.position, types.OBJECT, {} );\n    options.velocity = utils.ensureTypedArg( options.velocity, types.OBJECT, {} );\n    options.acceleration = utils.ensureTypedArg( options.acceleration, types.OBJECT, {} );\n    options.radius = utils.ensureTypedArg( options.radius, types.OBJECT, {} );\n    options.drag = utils.ensureTypedArg( options.drag, types.OBJECT, {} );\n    options.rotation = utils.ensureTypedArg( options.rotation, types.OBJECT, {} );\n    options.color = utils.ensureTypedArg( options.color, types.OBJECT, {} );\n    options.opacity = utils.ensureTypedArg( options.opacity, types.OBJECT, {} );\n    options.size = utils.ensureTypedArg( options.size, types.OBJECT, {} );\n    options.angle = utils.ensureTypedArg( options.angle, types.OBJECT, {} );\n    options.wiggle = utils.ensureTypedArg( options.wiggle, types.OBJECT, {} );\n    options.maxAge = utils.ensureTypedArg( options.maxAge, types.OBJECT, {} );\n\n    if ( options.onParticleSpawn ) {\n        console.warn( 'onParticleSpawn has been removed. Please set properties directly to alter values at runtime.' );\n    }\n\n    this.uuid = THREE.Math.generateUUID();\n\n    this.type = utils.ensureTypedArg( options.type, types.NUMBER, SPE.distributions.BOX );\n\n    // Start assigning properties...kicking it off with props that DON'T support values over\n    // lifetimes.\n    //\n    // Btw, values over lifetimes are just the new way of referring to *Start, *Middle, and *End.\n    this.position = {\n        _value: utils.ensureInstanceOf( options.position.value, THREE.Vector3, new THREE.Vector3() ),\n        _spread: utils.ensureInstanceOf( options.position.spread, THREE.Vector3, new THREE.Vector3() ),\n        _spreadClamp: utils.ensureInstanceOf( options.position.spreadClamp, THREE.Vector3, new THREE.Vector3() ),\n        _distribution: utils.ensureTypedArg( options.position.distribution, types.NUMBER, this.type ),\n        _randomise: utils.ensureTypedArg( options.position.randomise, types.BOOLEAN, false ),\n        _radius: utils.ensureTypedArg( options.position.radius, types.NUMBER, 10 ),\n        _radiusScale: utils.ensureInstanceOf( options.position.radiusScale, THREE.Vector3, new THREE.Vector3( 1, 1, 1 ) ),\n        _distributionClamp: utils.ensureTypedArg( options.position.distributionClamp, types.NUMBER, 0 ),\n    };\n\n    this.velocity = {\n        _value: utils.ensureInstanceOf( options.velocity.value, THREE.Vector3, new THREE.Vector3() ),\n        _spread: utils.ensureInstanceOf( options.velocity.spread, THREE.Vector3, new THREE.Vector3() ),\n        _distribution: utils.ensureTypedArg( options.velocity.distribution, types.NUMBER, this.type ),\n        _randomise: utils.ensureTypedArg( options.position.randomise, types.BOOLEAN, false )\n    };\n\n    this.acceleration = {\n        _value: utils.ensureInstanceOf( options.acceleration.value, THREE.Vector3, new THREE.Vector3() ),\n        _spread: utils.ensureInstanceOf( options.acceleration.spread, THREE.Vector3, new THREE.Vector3() ),\n        _distribution: utils.ensureTypedArg( options.acceleration.distribution, types.NUMBER, this.type ),\n        _randomise: utils.ensureTypedArg( options.position.randomise, types.BOOLEAN, false )\n    };\n\n    this.drag = {\n        _value: utils.ensureTypedArg( options.drag.value, types.NUMBER, 0 ),\n        _spread: utils.ensureTypedArg( options.drag.spread, types.NUMBER, 0 ),\n        _randomise: utils.ensureTypedArg( options.position.randomise, types.BOOLEAN, false )\n    };\n\n    this.wiggle = {\n        _value: utils.ensureTypedArg( options.wiggle.value, types.NUMBER, 0 ),\n        _spread: utils.ensureTypedArg( options.wiggle.spread, types.NUMBER, 0 )\n    };\n\n    this.rotation = {\n        _axis: utils.ensureInstanceOf( options.rotation.axis, THREE.Vector3, new THREE.Vector3( 0.0, 1.0, 0.0 ) ),\n        _axisSpread: utils.ensureInstanceOf( options.rotation.axisSpread, THREE.Vector3, new THREE.Vector3() ),\n        _angle: utils.ensureTypedArg( options.rotation.angle, types.NUMBER, 0 ),\n        _angleSpread: utils.ensureTypedArg( options.rotation.angleSpread, types.NUMBER, 0 ),\n        _static: utils.ensureTypedArg( options.rotation.static, types.BOOLEAN, false ),\n        _center: utils.ensureInstanceOf( options.rotation.center, THREE.Vector3, this.position._value.clone() ),\n        _randomise: utils.ensureTypedArg( options.position.randomise, types.BOOLEAN, false )\n    };\n\n\n    this.maxAge = {\n        _value: utils.ensureTypedArg( options.maxAge.value, types.NUMBER, 2 ),\n        _spread: utils.ensureTypedArg( options.maxAge.spread, types.NUMBER, 0 )\n    };\n\n\n\n    // The following properties can support either single values, or an array of values that change\n    // the property over a particle's lifetime (value over lifetime).\n    this.color = {\n        _value: utils.ensureArrayInstanceOf( options.color.value, THREE.Color, new THREE.Color() ),\n        _spread: utils.ensureArrayInstanceOf( options.color.spread, THREE.Vector3, new THREE.Vector3() ),\n        _randomise: utils.ensureTypedArg( options.position.randomise, types.BOOLEAN, false )\n    };\n\n    this.opacity = {\n        _value: utils.ensureArrayTypedArg( options.opacity.value, types.NUMBER, 1 ),\n        _spread: utils.ensureArrayTypedArg( options.opacity.spread, types.NUMBER, 0 ),\n        _randomise: utils.ensureTypedArg( options.position.randomise, types.BOOLEAN, false )\n    };\n\n    this.size = {\n        _value: utils.ensureArrayTypedArg( options.size.value, types.NUMBER, 1 ),\n        _spread: utils.ensureArrayTypedArg( options.size.spread, types.NUMBER, 0 ),\n        _randomise: utils.ensureTypedArg( options.position.randomise, types.BOOLEAN, false )\n    };\n\n    this.angle = {\n        _value: utils.ensureArrayTypedArg( options.angle.value, types.NUMBER, 0 ),\n        _spread: utils.ensureArrayTypedArg( options.angle.spread, types.NUMBER, 0 ),\n        _randomise: utils.ensureTypedArg( options.position.randomise, types.BOOLEAN, false )\n    };\n\n\n    // Assign renaining option values.\n    this.particleCount = utils.ensureTypedArg( options.particleCount, types.NUMBER, 100 );\n    this.duration = utils.ensureTypedArg( options.duration, types.NUMBER, null );\n    this.isStatic = utils.ensureTypedArg( options.isStatic, types.BOOLEAN, false );\n    this.activeMultiplier = utils.ensureTypedArg( options.activeMultiplier, types.NUMBER, 1 );\n    this.direction = utils.ensureTypedArg( options.direction, types.NUMBER, 1 );\n\n    // Whether this emitter is alive or not.\n    this.alive = utils.ensureTypedArg( options.alive, types.BOOLEAN, true );\n\n\n    // The following properties are set internally and are not\n    // user-controllable.\n    this.particlesPerSecond = 0;\n\n    // The current particle index for which particles should\n    // be marked as active on the next update cycle.\n    this.activationIndex = 0;\n\n    // The offset in the typed arrays this emitter's\n    // particle's values will start at\n    this.attributeOffset = 0;\n\n    // The end of the range in the attribute buffers\n    this.attributeEnd = 0;\n\n\n\n    // Holds the time the emitter has been alive for.\n    this.age = 0.0;\n\n    // Holds the number of currently-alive particles\n    this.activeParticleCount = 0.0;\n\n    // Holds a reference to this emitter's group once\n    // it's added to one.\n    this.group = null;\n\n    // Holds a reference to this emitter's group's attributes object\n    // for easier access.\n    this.attributes = null;\n\n    // Holds a reference to the params attribute's typed array\n    // for quicker access.\n    this.paramsArray = null;\n\n    // A set of flags to determine whether particular properties\n    // should be re-randomised when a particle is reset.\n    //\n    // If a `randomise` property is given, this is preferred.\n    // Otherwise, it looks at whether a spread value has been\n    // given.\n    //\n    // It allows randomization to be turned off as desired. If\n    // all randomization is turned off, then I'd expect a performance\n    // boost as no attribute buffers (excluding the `params`)\n    // would have to be re-passed to the GPU each frame (since nothing\n    // except the `params` attribute would have changed).\n    this.resetFlags = {\n        // params: utils.ensureTypedArg( options.maxAge.randomise, types.BOOLEAN, !!options.maxAge.spread ) ||\n        //     utils.ensureTypedArg( options.wiggle.randomise, types.BOOLEAN, !!options.wiggle.spread ),\n        position: utils.ensureTypedArg( options.position.randomise, types.BOOLEAN, false ) ||\n            utils.ensureTypedArg( options.radius.randomise, types.BOOLEAN, false ),\n        velocity: utils.ensureTypedArg( options.velocity.randomise, types.BOOLEAN, false ),\n        acceleration: utils.ensureTypedArg( options.acceleration.randomise, types.BOOLEAN, false ) ||\n            utils.ensureTypedArg( options.drag.randomise, types.BOOLEAN, false ),\n        rotation: utils.ensureTypedArg( options.rotation.randomise, types.BOOLEAN, false ),\n        rotationCenter: utils.ensureTypedArg( options.rotation.randomise, types.BOOLEAN, false ),\n        size: utils.ensureTypedArg( options.size.randomise, types.BOOLEAN, false ),\n        color: utils.ensureTypedArg( options.color.randomise, types.BOOLEAN, false ),\n        opacity: utils.ensureTypedArg( options.opacity.randomise, types.BOOLEAN, false ),\n        angle: utils.ensureTypedArg( options.angle.randomise, types.BOOLEAN, false )\n    };\n\n    this.updateFlags = {};\n    this.updateCounts = {};\n\n    // A map to indicate which emitter parameters should update\n    // which attribute.\n    this.updateMap = {\n        maxAge: 'params',\n        position: 'position',\n        velocity: 'velocity',\n        acceleration: 'acceleration',\n        drag: 'acceleration',\n        wiggle: 'params',\n        rotation: 'rotation',\n        size: 'size',\n        color: 'color',\n        opacity: 'opacity',\n        angle: 'angle'\n    };\n\n    for ( var i in this.updateMap ) {\n        if ( this.updateMap.hasOwnProperty( i ) ) {\n            this.updateCounts[ this.updateMap[ i ] ] = 0.0;\n            this.updateFlags[ this.updateMap[ i ] ] = false;\n            this._createGetterSetters( this[ i ], i );\n        }\n    }\n\n    this.bufferUpdateRanges = {};\n    this.attributeKeys = null;\n    this.attributeCount = 0;\n\n\n    // Ensure that the value-over-lifetime property objects above\n    // have value and spread properties that are of the same length.\n    //\n    // Also, for now, make sure they have a length of 3 (min/max arguments here).\n    utils.ensureValueOverLifetimeCompliance( this.color, lifetimeLength, lifetimeLength );\n    utils.ensureValueOverLifetimeCompliance( this.opacity, lifetimeLength, lifetimeLength );\n    utils.ensureValueOverLifetimeCompliance( this.size, lifetimeLength, lifetimeLength );\n    utils.ensureValueOverLifetimeCompliance( this.angle, lifetimeLength, lifetimeLength );\n};\n\nSPE.Emitter.constructor = SPE.Emitter;\n\nSPE.Emitter.prototype._createGetterSetters = function( propObj, propName ) {\n    'use strict';\n\n    var self = this;\n\n    for ( var i in propObj ) {\n        if ( propObj.hasOwnProperty( i ) ) {\n\n            var name = i.replace( '_', '' );\n\n            Object.defineProperty( propObj, name, {\n                get: ( function( prop ) {\n                    return function() {\n                        return this[ prop ];\n                    };\n                }( i ) ),\n\n                set: ( function( prop ) {\n                    return function( value ) {\n                        var mapName = self.updateMap[ propName ],\n                            prevValue = this[ prop ],\n                            length = SPE.valueOverLifetimeLength;\n\n                        if ( prop === '_rotationCenter' ) {\n                            self.updateFlags.rotationCenter = true;\n                            self.updateCounts.rotationCenter = 0.0;\n                        }\n                        else if ( prop === '_randomise' ) {\n                            self.resetFlags[ mapName ] = value;\n                        }\n                        else {\n                            self.updateFlags[ mapName ] = true;\n                            self.updateCounts[ mapName ] = 0.0;\n                        }\n\n                        self.group._updateDefines();\n\n                        this[ prop ] = value;\n\n                        // If the previous value was an array, then make\n                        // sure the provided value is interpolated correctly.\n                        if ( Array.isArray( prevValue ) ) {\n                            SPE.utils.ensureValueOverLifetimeCompliance( self[ propName ], length, length );\n                        }\n                    };\n                }( i ) )\n            } );\n        }\n    }\n};\n\nSPE.Emitter.prototype._setBufferUpdateRanges = function( keys ) {\n    'use strict';\n\n    this.attributeKeys = keys;\n    this.attributeCount = keys.length;\n\n    for ( var i = this.attributeCount - 1; i >= 0; --i ) {\n        this.bufferUpdateRanges[ keys[ i ] ] = {\n            min: Number.POSITIVE_INFINITY,\n            max: Number.NEGATIVE_INFINITY\n        };\n    }\n};\n\nSPE.Emitter.prototype._calculatePPSValue = function( groupMaxAge ) {\n    'use strict';\n\n    var particleCount = this.particleCount;\n\n\n    // Calculate the `particlesPerSecond` value for this emitter. It's used\n    // when determining which particles should die and which should live to\n    // see another day. Or be born, for that matter. The \"God\" property.\n    if ( this.duration ) {\n        this.particlesPerSecond = particleCount / ( groupMaxAge < this.duration ? groupMaxAge : this.duration );\n    }\n    else {\n        this.particlesPerSecond = particleCount / groupMaxAge;\n    }\n};\n\nSPE.Emitter.prototype._setAttributeOffset = function( startIndex ) {\n    this.attributeOffset = startIndex;\n    this.activationIndex = startIndex;\n    this.activationEnd = startIndex + this.particleCount;\n};\n\n\nSPE.Emitter.prototype._assignValue = function( prop, index ) {\n    'use strict';\n\n    switch ( prop ) {\n        case 'position':\n            this._assignPositionValue( index );\n            break;\n\n        case 'velocity':\n        case 'acceleration':\n            this._assignForceValue( index, prop );\n            break;\n\n        case 'size':\n        case 'opacity':\n            this._assignAbsLifetimeValue( index, prop );\n            break;\n\n        case 'angle':\n            this._assignAngleValue( index );\n            break;\n\n        case 'params':\n            this._assignParamsValue( index );\n            break;\n\n        case 'rotation':\n            this._assignRotationValue( index );\n            break;\n\n        case 'color':\n            this._assignColorValue( index );\n            break;\n    }\n};\n\nSPE.Emitter.prototype._assignPositionValue = function( index ) {\n    'use strict';\n\n    var distributions = SPE.distributions,\n        utils = SPE.utils,\n        prop = this.position,\n        attr = this.attributes.position,\n        value = prop._value,\n        spread = prop._spread,\n        distribution = prop._distribution;\n\n    switch ( distribution ) {\n        case distributions.BOX:\n            utils.randomVector3( attr, index, value, spread, prop._spreadClamp );\n            break;\n\n        case distributions.SPHERE:\n            utils.randomVector3OnSphere( attr, index, value, prop._radius, prop._spread.x, prop._radiusScale, prop._spreadClamp.x, prop._distributionClamp || this.particleCount );\n            break;\n\n        case distributions.DISC:\n            utils.randomVector3OnDisc( attr, index, value, prop._radius, prop._spread.x, prop._radiusScale, prop._spreadClamp.x );\n            break;\n    }\n};\n\nSPE.Emitter.prototype._assignForceValue = function( index, attrName ) {\n    'use strict';\n\n    var distributions = SPE.distributions,\n        utils = SPE.utils,\n        prop = this[ attrName ],\n        value = prop._value,\n        spread = prop._spread,\n        distribution = prop._distribution,\n        pos,\n        positionX,\n        positionY,\n        positionZ,\n        i;\n\n    switch ( distribution ) {\n        case distributions.BOX:\n            utils.randomVector3( this.attributes[ attrName ], index, value, spread );\n            break;\n\n        case distributions.SPHERE:\n            pos = this.attributes.position.typedArray.array;\n            i = index * 3;\n\n            // Ensure position values aren't zero, otherwise no force will be\n            // applied.\n            // positionX = utils.zeroToEpsilon( pos[ i ], true );\n            // positionY = utils.zeroToEpsilon( pos[ i + 1 ], true );\n            // positionZ = utils.zeroToEpsilon( pos[ i + 2 ], true );\n            positionX = pos[ i ];\n            positionY = pos[ i + 1 ];\n            positionZ = pos[ i + 2 ];\n\n            utils.randomDirectionVector3OnSphere(\n                this.attributes[ attrName ], index,\n                positionX, positionY, positionZ,\n                this.position._value,\n                prop._value.x,\n                prop._spread.x\n            );\n            break;\n\n        case distributions.DISC:\n            pos = this.attributes.position.typedArray.array;\n            i = index * 3;\n\n            // Ensure position values aren't zero, otherwise no force will be\n            // applied.\n            // positionX = utils.zeroToEpsilon( pos[ i ], true );\n            // positionY = utils.zeroToEpsilon( pos[ i + 1 ], true );\n            // positionZ = utils.zeroToEpsilon( pos[ i + 2 ], true );\n            positionX = pos[ i ];\n            positionY = pos[ i + 1 ];\n            positionZ = pos[ i + 2 ];\n\n            utils.randomDirectionVector3OnDisc(\n                this.attributes[ attrName ], index,\n                positionX, positionY, positionZ,\n                this.position._value,\n                prop._value.x,\n                prop._spread.x\n            );\n            break;\n    }\n\n    if ( attrName === 'acceleration' ) {\n        var drag = utils.clamp( utils.randomFloat( this.drag._value, this.drag._spread ), 0, 1 );\n        this.attributes.acceleration.typedArray.array[ index * 4 + 3 ] = drag;\n    }\n};\n\nSPE.Emitter.prototype._assignAbsLifetimeValue = function( index, propName ) {\n    'use strict';\n\n    var array = this.attributes[ propName ].typedArray,\n        prop = this[ propName ],\n        utils = SPE.utils,\n        value;\n\n    if ( utils.arrayValuesAreEqual( prop._value ) && utils.arrayValuesAreEqual( prop._spread ) ) {\n        value = Math.abs( utils.randomFloat( prop._value[ 0 ], prop._spread[ 0 ] ) );\n        array.setVec4Components( index, value, value, value, value );\n    }\n    else {\n        array.setVec4Components( index,\n            Math.abs( utils.randomFloat( prop._value[ 0 ], prop._spread[ 0 ] ) ),\n            Math.abs( utils.randomFloat( prop._value[ 1 ], prop._spread[ 1 ] ) ),\n            Math.abs( utils.randomFloat( prop._value[ 2 ], prop._spread[ 2 ] ) ),\n            Math.abs( utils.randomFloat( prop._value[ 3 ], prop._spread[ 3 ] ) )\n        );\n    }\n};\n\nSPE.Emitter.prototype._assignAngleValue = function( index ) {\n    'use strict';\n\n    var array = this.attributes.angle.typedArray,\n        prop = this.angle,\n        utils = SPE.utils,\n        value;\n\n    if ( utils.arrayValuesAreEqual( prop._value ) && utils.arrayValuesAreEqual( prop._spread ) ) {\n        value = utils.randomFloat( prop._value[ 0 ], prop._spread[ 0 ] );\n        array.setVec4Components( index, value, value, value, value );\n    }\n    else {\n        array.setVec4Components( index,\n            utils.randomFloat( prop._value[ 0 ], prop._spread[ 0 ] ),\n            utils.randomFloat( prop._value[ 1 ], prop._spread[ 1 ] ),\n            utils.randomFloat( prop._value[ 2 ], prop._spread[ 2 ] ),\n            utils.randomFloat( prop._value[ 3 ], prop._spread[ 3 ] )\n        );\n    }\n};\n\nSPE.Emitter.prototype._assignParamsValue = function( index ) {\n    'use strict';\n\n    this.attributes.params.typedArray.setVec4Components( index,\n        this.isStatic ? 1 : 0,\n        0.0,\n        Math.abs( SPE.utils.randomFloat( this.maxAge._value, this.maxAge._spread ) ),\n        SPE.utils.randomFloat( this.wiggle._value, this.wiggle._spread )\n    );\n};\n\nSPE.Emitter.prototype._assignRotationValue = function( index ) {\n    'use strict';\n\n    this.attributes.rotation.typedArray.setVec3Components( index,\n        SPE.utils.getPackedRotationAxis( this.rotation._axis, this.rotation._axisSpread ),\n        SPE.utils.randomFloat( this.rotation._angle, this.rotation._angleSpread ),\n        this.rotation._static ? 0 : 1\n    );\n\n    this.attributes.rotationCenter.typedArray.setVec3( index, this.rotation._center );\n};\n\nSPE.Emitter.prototype._assignColorValue = function( index ) {\n    'use strict';\n    SPE.utils.randomColorAsHex( this.attributes.color, index, this.color._value, this.color._spread );\n};\n\nSPE.Emitter.prototype._resetParticle = function( index ) {\n    'use strict';\n\n    var resetFlags = this.resetFlags,\n        updateFlags = this.updateFlags,\n        updateCounts = this.updateCounts,\n        keys = this.attributeKeys,\n        key,\n        updateFlag;\n\n    for ( var i = this.attributeCount - 1; i >= 0; --i ) {\n        key = keys[ i ];\n        updateFlag = updateFlags[ key ];\n\n        if ( resetFlags[ key ] === true || updateFlag === true ) {\n            this._assignValue( key, index );\n            this._updateAttributeUpdateRange( key, index );\n\n            if ( updateFlag === true && updateCounts[ key ] === this.particleCount ) {\n                updateFlags[ key ] = false;\n                updateCounts[ key ] = 0.0;\n            }\n            else if ( updateFlag == true ) {\n                ++updateCounts[ key ];\n            }\n        }\n    }\n};\n\nSPE.Emitter.prototype._updateAttributeUpdateRange = function( attr, i ) {\n    'use strict';\n\n    var ranges = this.bufferUpdateRanges[ attr ];\n\n    ranges.min = Math.min( i, ranges.min );\n    ranges.max = Math.max( i, ranges.max );\n};\n\nSPE.Emitter.prototype._resetBufferRanges = function() {\n    'use strict';\n\n    var ranges = this.bufferUpdateRanges,\n        keys = this.bufferUpdateKeys,\n        i = this.bufferUpdateCount - 1,\n        key;\n\n    for ( i; i >= 0; --i ) {\n        key = keys[ i ];\n        ranges[ key ].min = Number.POSITIVE_INFINITY;\n        ranges[ key ].max = Number.NEGATIVE_INFINITY;\n    }\n};\n\nSPE.Emitter.prototype._onRemove = function() {\n    'use strict';\n    // Reset any properties of the emitter that were set by\n    // a group when it was added.\n    this.particlesPerSecond = 0;\n    this.attributeOffset = 0;\n    this.activationIndex = 0;\n    this.activeParticleCount = 0;\n    this.group = null;\n    this.attributes = null;\n    this.paramsArray = null;\n    this.age = 0.0;\n};\n\nSPE.Emitter.prototype._decrementParticleCount = function() {\n    'use strict';\n    --this.activeParticleCount;\n\n    // TODO:\n    //  - Trigger event if count === 0.\n};\n\nSPE.Emitter.prototype._incrementParticleCount = function() {\n    'use strict';\n    ++this.activeParticleCount;\n\n    // TODO:\n    //  - Trigger event if count === this.particleCount.\n};\n\nSPE.Emitter.prototype._checkParticleAges = function( start, end, params, dt ) {\n    'use strict';\n    for ( var i = end - 1, index, maxAge, age, alive; i >= start; --i ) {\n        index = i * 4;\n\n        alive = params[ index ];\n\n        if ( alive === 0.0 ) {\n            continue;\n        }\n\n        // Increment age\n        age = params[ index + 1 ];\n        maxAge = params[ index + 2 ];\n\n        if ( this.direction === 1 ) {\n            age += dt;\n\n            if ( age >= maxAge ) {\n                age = 0.0;\n                alive = 0.0;\n                this._decrementParticleCount();\n            }\n        }\n        else {\n            age -= dt;\n\n            if ( age <= 0.0 ) {\n                age = maxAge;\n                alive = 0.0;\n                this._decrementParticleCount();\n            }\n        }\n\n        params[ index ] = alive;\n        params[ index + 1 ] = age;\n\n        this._updateAttributeUpdateRange( 'params', i );\n    }\n};\n\nSPE.Emitter.prototype._activateParticles = function( activationStart, activationEnd, params, dtPerParticle ) {\n    'use strict';\n    var direction = this.direction;\n\n    for ( var i = activationStart, index, dtValue; i < activationEnd; ++i ) {\n        index = i * 4;\n\n        // Don't re-activate particles that aren't dead yet.\n        // if ( params[ index ] !== 0.0 && ( this.particleCount !== 1 || this.activeMultiplier !== 1 ) ) {\n        //     continue;\n        // }\n\n        if ( params[ index ] != 0.0 && this.particleCount !== 1 ) {\n            continue;\n        }\n\n        // Increment the active particle count.\n        this._incrementParticleCount();\n\n        // Mark the particle as alive.\n        params[ index ] = 1.0;\n\n        // Reset the particle\n        this._resetParticle( i );\n\n        // Move each particle being activated to\n        // it's actual position in time.\n        //\n        // This stops particles being 'clumped' together\n        // when frame rates are on the lower side of 60fps\n        // or not constant (a very real possibility!)\n        dtValue = dtPerParticle * ( i - activationStart )\n        params[ index + 1 ] = direction === -1 ? params[ index + 2 ] - dtValue : dtValue;\n\n        this._updateAttributeUpdateRange( 'params', i );\n    }\n};\n\n/**\n * Simulates one frame's worth of particles, updating particles\n * that are already alive, and marking ones that are currently dead\n * but should be alive as alive.\n *\n * If the emitter is marked as static, then this function will do nothing.\n *\n * @param  {Number} dt The number of seconds to simulate (deltaTime)\n */\nSPE.Emitter.prototype.tick = function( dt ) {\n    'use strict';\n\n    if ( this.isStatic ) {\n        return;\n    }\n\n    if ( this.paramsArray === null ) {\n        this.paramsArray = this.attributes.params.typedArray.array;\n    }\n\n    var start = this.attributeOffset,\n        end = start + this.particleCount,\n        params = this.paramsArray, // vec3( alive, age, maxAge, wiggle )\n        ppsDt = this.particlesPerSecond * this.activeMultiplier * dt,\n        activationIndex = this.activationIndex;\n\n    // Reset the buffer update indices.\n    this._resetBufferRanges();\n\n    // Increment age for those particles that are alive,\n    // and kill off any particles whose age is over the limit.\n    this._checkParticleAges( start, end, params, dt );\n\n    // If the emitter is dead, reset the age of the emitter to zero,\n    // ready to go again if required\n    if ( this.alive === false ) {\n        this.age = 0.0;\n        return;\n    }\n\n    // If the emitter has a specified lifetime and we've exceeded it,\n    // mark the emitter as dead.\n    if ( this.duration !== null && this.age > this.duration ) {\n        this.alive = false;\n        this.age = 0.0;\n        return;\n    }\n\n\n    var activationStart = this.particleCount === 1 ? activationIndex : ( activationIndex | 0 ),\n        activationEnd = Math.min( activationStart + ppsDt, this.activationEnd ),\n        activationCount = activationEnd - this.activationIndex | 0,\n        dtPerParticle = activationCount > 0 ? dt / activationCount : 0;\n\n    this._activateParticles( activationStart, activationEnd, params, dtPerParticle );\n\n    // Move the activation window forward, soldier.\n    this.activationIndex += ppsDt;\n\n    if ( this.activationIndex > end ) {\n        this.activationIndex = start;\n    }\n\n\n    // Increment the age of the emitter.\n    this.age += dt;\n};\n\n/**\n * Resets all the emitter's particles to their start positions\n * and marks the particles as dead if the `force` argument is\n * true.\n *\n * @param  {Boolean} [force=undefined] If true, all particles will be marked as dead instantly.\n * @return {Emitter}       This emitter instance.\n */\nSPE.Emitter.prototype.reset = function( force ) {\n    'use strict';\n\n    this.age = 0.0;\n    this.alive = false;\n\n    if ( force === true ) {\n        var start = this.attributeOffset,\n            end = start + this.particleCount,\n            array = this.paramsArray,\n            attr = this.attributes.params.bufferAttribute;\n\n        for ( var i = end - 1, index; i >= start; --i ) {\n            index = i * 4;\n\n            array[ index ] = 0.0;\n            array[ index + 1 ] = 0.0;\n        }\n\n        attr.updateRange.offset = 0;\n        attr.updateRange.count = -1;\n        attr.needsUpdate = true;\n    }\n\n    return this;\n};\n\n/**\n * Enables the emitter. If not already enabled, the emitter\n * will start emitting particles.\n *\n * @return {Emitter} This emitter instance.\n */\nSPE.Emitter.prototype.enable = function() {\n    'use strict';\n    this.alive = true;\n    return this;\n};\n\n/**\n * Disables th emitter, but does not instantly remove it's\n * particles fromt the scene. When called, the emitter will be\n * 'switched off' and just stop emitting. Any particle's alive will\n * be allowed to finish their lifecycle.\n *\n * @return {Emitter} This emitter instance.\n */\nSPE.Emitter.prototype.disable = function() {\n    'use strict';\n\n    this.alive = false;\n    return this;\n};\n\n/**\n * Remove this emitter from it's parent group (if it has been added to one).\n * Delgates to SPE.group.prototype.removeEmitter().\n *\n * When called, all particle's belonging to this emitter will be instantly\n * removed from the scene.\n *\n * @return {Emitter} This emitter instance.\n *\n * @see SPE.Group.prototype.removeEmitter\n */\nSPE.Emitter.prototype.remove = function() {\n    'use strict';\n    if ( this.group !== null ) {\n        this.group.removeEmitter( this );\n    }\n    else {\n        console.error( 'Emitter does not belong to a group, cannot remove.' );\n    }\n\n    return this;\n};\n"]},"metadata":{},"sourceType":"script"}